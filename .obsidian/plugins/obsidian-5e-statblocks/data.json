{
  "monsters": [],
  "defaultLayouts": {},
  "layouts": [
    {
      "blocks": [
        {
          "type": "inline",
          "id": "0bdbf8e98b69",
          "properties": [],
          "hasRule": false,
          "nested": [
            {
              "type": "group",
              "id": "dac95b5a795b",
              "properties": [
                "name"
              ],
              "nested": [
                {
                  "type": "inline",
                  "id": "bab8f97afb6a",
                  "properties": [],
                  "hasRule": false,
                  "nested": [
                    {
                      "type": "heading",
                      "id": "78eb3acaa999",
                      "properties": [
                        "name"
                      ],
                      "conditioned": true,
                      "size": 1
                    },
                    {
                      "type": "inline",
                      "id": "b93b4a3a5b18",
                      "properties": [],
                      "hasRule": false,
                      "nested": [
                        {
                          "type": "action",
                          "id": "598a9b596a18",
                          "icon": "sword",
                          "callback": "try { InitiativeTracker.newEncounter({roll: true, creatures: [monster]}); } catch(e) {}"
                        },
                        {
                          "type": "action",
                          "id": "fabb9b089939",
                          "icon": "plus-with-circle",
                          "callback": "try { InitiativeTracker.addCreatures([monster]); } catch(e) {}"
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "property",
                  "id": "info-table",
                  "display": "",
                  "properties": [
                    "alter",
                    "geschlecht",
                    "haarfarbe",
                    "augenfarbe",
                    "groesse",
                    "gewicht",
                    "spezies",
                    "kultur",
                    "geburtsort",
                    "profession",
                    "sozialstatus"
                  ],
                  "conditioned": false,
                  "callback": "const get = k => monster[k] ?? monster.info?.[k] ?? '-';\nconst allowed = ['Mensch', 'Elf', 'Halbelf', 'Zwerg'];\nconst raw = monster.info?.spezies ?? monster.info?.species ?? monster.spezies;\nconst species = typeof raw === 'string' ? raw.trim() : '';\nconst spVal = allowed.includes(species) ? species : 'Mensch/Elf/Halbelf/Zwerg';\nconst rows = [\n    ['Alter:', get('alter'), 'Geschlecht:', get('geschlecht') || 'm/w/d'],\n    ['Haarfarbe:', get('haarfarbe'), 'Augenfarbe:', get('augenfarbe')],\n    ['Gr√∂√üe:', get('groesse'), 'Gewicht:', get('gewicht')],\n    ['Spezies:', spVal, 'Kultur:', get('kultur')],\n    ['Geburtsort:', get('geburtsort'), 'Profession:', get('profession')],\n    ['Sozialstatus:', get('sozialstatus') || 'Unfrei/Frei/Niederadel/Adel/Hochadel', '', '']\n];\nreturn `<table class=\"info-grid\" style=\"width:100%;border-collapse:collapse;\"><tbody>${rows.map(r => `<tr><td style=\"text-align:right;font-weight:bold;padding:2px 8px;width:25%;\">${r[0]}</td><td style=\"text-align:left;padding:2px 8px;width:25%;\">${r[1]}</td><td style=\"text-align:right;font-weight:bold;padding:2px 8px;width:25%;\">${r[2]}</td><td style=\"text-align:left;padding:2px 8px;width:25%;\">${r[3]}</td></tr>`).join('')}</tbody></table>`;"
                },
                {
                  "type": "group",
                  "id": "3ad858d9293b",
                  "properties": [],
                  "nested": [
                    {
                      "type": "property",
                      "id": "calc-values-table",
                      "display": "",
                      "properties": [
                        "le",
                        "le_mod",
                        "ae",
                        "ae_mod",
                        "ae_max",
                        "ke",
                        "ke_mod",
                        "ke_max",
                        "schip",
                        "schip_max",
                        "spezies",
                        "sk_mod",
                        "zk_mod",
                        "aw_mod",
                        "ini_mod",
                        "ws_mod",
                        "gs_mod"
                      ],
                      "conditioned": false,
                      "callback": "const bases = {'Mensch': { le: 5, sk: -5, zk: -5, gs: 8 }, 'Elf': { le: 2, sk: -4, zk: -6, gs: 8 }, 'Halbelf': { le: 5, sk: -4, zk: -6, gs: 8 }, 'Zwerg': { le: 8, sk: -4, zk: -4, gs: 6 }};\nconst toNum = v => { if (typeof v === 'number') return v; if (typeof v === 'string' && v.trim() !== '') { const p = Number(v); return Number.isFinite(p) ? p : 0; } return 0; };\nconst rawSpecies = monster.info?.spezies ?? monster.info?.species ?? monster.spezies ?? monster.species;\nconst species = typeof rawSpecies === 'string' ? rawSpecies.trim() : '';\nconst b = bases[species] ?? {};\nconst attrs = monster.eigenschaften ?? {};\nconst attr = k => toNum(attrs[k] ?? monster[k] ?? monster[`eigenschaften.${k}`]);\nconst get = k => monster[k] ?? '-';\nconst ko = attr('ko'); const mu = attr('mu'); const ge = attr('ge'); const kl = attr('kl'); const iin = attr('in'); const kk = attr('kk');\nconst modLE = toNum(monster.le_mod ?? 0);\nconst maxLE = b.le !== undefined ? b.le + (2 * ko) + modLE : '-';\nconst skMod = toNum(monster.sk_mod ?? 0); const zkMod = toNum(monster.zk_mod ?? 0); const awMod = toNum(monster.aw_mod ?? 0); const iniMod = toNum(monster.ini_mod ?? 0); const wsMod = toNum(monster.ws_mod ?? 0);\nconst awBase = Number.isFinite(ge) ? Math.round(ge / 2) : 0; const aw = awBase + awMod;\nconst iniBase = (Number.isFinite(mu) && Number.isFinite(ge)) ? Math.round((mu + ge) / 2) : 0; const ini = iniBase + iniMod;\nconst skBase = b.sk !== undefined ? Math.round((mu + kl + iin) / 6) + b.sk : 0; const sk = skBase + skMod;\nconst zkBase = b.zk !== undefined ? Math.round((ko + ko + kk) / 6) + b.zk : 0; const zk = zkBase + zkMod;\nconst wsBase = Number.isFinite(ko) ? Math.round(ko / 2) : 0; const ws = wsBase + wsMod;\nconst gsBase = b.gs ?? 0; const gsMod = toNum(monster.gs_mod ?? 0); const gs = gsBase + gsMod;\nconst aeMax = toNum(monster.ae_max ?? 0);\nconst keMax = toNum(monster.ke_max ?? 0);\nconst fmtMod = (base, mod, total) => mod !== 0 ? `${total} (${base}${mod >= 0 ? '+' : ''}${mod})` : `${total}`;\nconst rows = [\n    ['LE:', get('le'), 'Mod. LE:', get('le_mod'), 'Max LE:', maxLE]\n];\nif (aeMax > 0) rows.push(['AE:', get('ae'), 'Mod. AE:', get('ae_mod'), 'Max AE:', get('ae_max')]);\nif (keMax > 0) rows.push(['KE:', get('ke'), 'Mod. KE:', get('ke_mod'), 'Max KE:', get('ke_max')]);\nrows.push(['SK:', fmtMod(skBase, skMod, sk), 'ZK:', fmtMod(zkBase, zkMod, zk), 'GS:', gsBase > 0 ? fmtMod(gsBase, gsMod, gs) : '-']);\nrows.push(['AW:', fmtMod(awBase, awMod, aw), 'Ini:', fmtMod(iniBase, iniMod, ini), 'WS:', fmtMod(wsBase, wsMod, ws)]);\nrows.push(['SchiP:', get('schip'), 'Max SchiP:', get('schip_max'), '', '']);\nconst cell = (txt, bold) => `<td style=\"text-align:${bold ? 'right' : 'left'};${bold ? 'font-weight:bold;' : ''}padding:2px 8px;\">${txt}</td>`;\nreturn `<table class=\"grundwerte-grid\" style=\"width:100%;border-collapse:collapse;\"><tbody>${rows.map(r => `<tr>${cell(r[0],true)}${cell(r[1],false)}${cell(r[2],true)}${cell(r[3],false)}${cell(r[4],true)}${cell(r[5],false)}</tr>`).join('')}</tbody></table>`;"
                    }
                  ],
                  "heading": "Grundwerte",
                  "hasRule": false,
                  "cls": "baseValues"
                }
              ],
              "conditioned": true,
              "cls": "baseInfo"
            },
            {
              "type": "image",
              "id": "7b3b093a59f9",
              "properties": [
                "image"
              ],
              "fallback": ""
            }
          ]
        },
        {
          "type": "inline",
          "id": "6809082b5b4a",
          "heading": "Eigenschaften",
          "properties": [
            "eigenschaften"
          ],
          "hasRule": false,
          "conditioned": true,
          "nested": [
            {
              "type": "property",
              "id": "eigenschaften-table",
              "display": "",
              "properties": [
                "mu",
                "kl",
                "in",
                "ch",
                "ff",
                "ge",
                "ko",
                "kk",
                "ap_gesamt"
              ],
              "conditioned": false,
              "callback": "const attrs = monster.eigenschaften ?? {};\nconst get = k => attrs[k] ?? monster[k] ?? monster[`eigenschaften.${k}`] ?? '-';\nconst headers = ['MU', 'KL', 'IN', 'CH', 'FF', 'GE', 'KO', 'KK'];\nconst keys = ['mu', 'kl', 'in', 'ch', 'ff', 'ge', 'ko', 'kk'];\nconst values = keys.map(k => get(k));\nconst ap = monster.ap_gesamt ?? 0;\nconst apBox = `<div style=\"display:inline-flex;flex-direction:column;align-items:center;justify-content:center;padding:8px 16px;background:var(--bar-color);border-radius:4px;border:1px solid var(--border-color);margin-left:12px;\"><span style=\"font-size:0.8em;color:var(--property-name-font-color);\">AP</span><span style=\"font-size:1.3em;font-weight:bold;\">${ap}</span></div>`;\nreturn `<div style=\"display:flex;align-items:center;\"><table class=\"eigenschaften-table\" style=\"flex:1;border-collapse:collapse;text-align:center;\"><thead><tr>${headers.map(h => `<th style=\"padding:6px 10px;\">${h}</th>`).join('')}</tr></thead><tbody><tr>${values.map(v => `<td style=\"padding:6px 10px;\">${v}</td>`).join('')}</tr></tbody></table>${apBox}</div>`;"
            }
          ]
        },
        {
          "type": "inline",
          "id": "talent-dice-section",
          "heading": "W√ºrfel",
          "properties": [
            "3d20",
            "1d20"
          ],
          "conditioned": true,
          "nested": [
            {
              "type": "property",
              "id": "talent-dice",
              "display": "üé≤ Fertigkeitenprobe w√ºrfeln",
              "properties": [
                "3d20"
              ],
              "fallback": "",
              "conditioned": true,
              "markdown": true
            }
          ]
        },
        {
          "type": "group",
          "id": "cbf94b49e91a",
          "properties": [],
          "nested": [
            {
              "type": "collapse",
              "id": "5b2bbbdb7b4b",
              "heading": "",
              "hasRule": false,
              "conditioned": false,
              "nested": [
                {
                  "type": "group",
                  "id": "7b491afa2aca",
                  "properties": [],
                  "nested": [
                    {
                      "type": "collapse",
                      "id": "ca783a6b2959",
                      "heading": "Nahkampfwaffen",
                      "hasRule": false,
                      "conditioned": true,
                      "properties": [
                        "nahkampfwaffen"
                      ],
                      "nested": [
                        {
                          "type": "group",
                          "id": "6bfb08aa8aeb",
                          "properties": [],
                          "nested": [
                            {
                              "type": "property",
                              "id": "nahkampfwaffen-table",
                              "display": "",
                              "properties": [
                                "nahkampfwaffen"
                              ],
                              "fallback": "",
                              "conditioned": true,
                              "callback": "const weapons = monster.nahkampfwaffen ?? [];\nif (!Array.isArray(weapons) || weapons.length === 0) return \"\";\nconst escapeHtml = str => String(str ?? \"\").replace(/[&<>\"']/g, c => ({ \"&\": \"&amp;\", \"<\": \"&lt;\", \">\": \"&gt;\", '\"': \"&quot;\", \"'\": \"&#39;\" }[c] || c));\nconst toNum = v => { if (typeof v === \"number\") return v; if (typeof v === \"string\") { const p = Number(v.trim()); return Number.isFinite(p) ? p : 0; } return 0; };\nconst toUmlaut = s => s.replace(/oe/g, '√∂').replace(/ae/g, '√§').replace(/ue/g, '√º');\nconst toAscii = s => s.replace(/√∂/g, 'oe').replace(/√§/g, 'ae').replace(/√º/g, 'ue');\nconst attrNames = { mu: \"MU\", kl: \"KL\", in: \"IN\", ch: \"CH\", ff: \"FF\", ge: \"GE\", ko: \"KO\", kk: \"KK\" };\nconst techMap = {\n    \"dolche\": { attrKeys: [\"ge\"], parry: true },\n    \"f√§cher\": { attrKeys: [\"ge\"], parry: true },\n    \"fechtwaffen\": { attrKeys: [\"ge\"], parry: true },\n    \"hiebwaffen\": { attrKeys: [\"kk\"], parry: true },\n    \"kettenwaffen\": { attrKeys: [\"kk\"], parry: false },\n    \"lanzen\": { attrKeys: [\"kk\"], parry: true },\n    \"peitschen\": { attrKeys: [\"ge\"], parry: false },\n    \"raufen\": { attrKeys: [\"ge\", \"kk\"], parry: true },\n    \"schilde\": { attrKeys: [\"kk\"], parry: true },\n    \"schwerter\": { attrKeys: [\"ge\", \"kk\"], parry: true },\n    \"stangenwaffen\": { attrKeys: [\"ge\", \"kk\"], parry: true },\n    \"zweihandhiebwaffen\": { attrKeys: [\"kk\"], parry: true },\n    \"zweihandschwerter\": { attrKeys: [\"kk\"], parry: true }\n};\nconst attrs = monster.eigenschaften ?? {};\nconst getAttr = k => toNum(attrs[k] ?? monster[k] ?? monster[`eigenschaften.${k}`]);\nconst bonusFromAttr = k => { const v = getAttr(k); return v <= 8 ? 0 : Math.round((v - 8) / 3); };\nconst getKtw = key => {\n    const store = monster.kampftechniken ?? {};\n    const k = key.toLowerCase().replace(/[^a-z√§√∂√º√ü]/g, \"\");\n    if (k in store) return toNum(store[k]);\n    for (const storeKey in store) { if (toUmlaut(storeKey) === k) return toNum(store[storeKey]); }\n    const kAscii = toAscii(k);\n    if (kAscii in store) return toNum(store[kAscii]);\n    for (const storeKey in store) { if (storeKey.toLowerCase() === k || storeKey.toLowerCase() === kAscii) return toNum(store[storeKey]); }\n    if (`kampftechniken.${k}` in monster) return toNum(monster[`kampftechniken.${k}`]);\n    return 6;\n};\nconst getMaxLAttr = lField => {\n    if (!lField) return 0;\n    const lStr = String(lField).toLowerCase();\n    const parts = lStr.split('/').map(p => p.trim());\n    let maxVal = 0;\n    for (const part of parts) {\n        const val = getAttr(part);\n        if (val > maxVal) maxVal = val;\n    }\n    return maxVal;\n};\nconst cols = 12;\nconst renderRows = () => weapons.map(w => {\n    const waffe = escapeHtml(w.waffe ?? w.name ?? \"-\");\n    const techRaw = String(w.kampftechnik ?? w.technik ?? \"\").toLowerCase().replace(/[^a-z√§√∂√º]/g, \"\");\n    const kampftechnik = escapeHtml(w.kampftechnik ?? w.technik ?? \"-\");\n    const lDisplay = escapeHtml(w.l ?? \"-\");\n    const sVal = toNum(w.s ?? 0);\n    const lAttrVal = getMaxLAttr(w.l);\n    const tpBonus = lAttrVal > sVal ? lAttrVal - sVal : 0;\n    const tpBase = escapeHtml(w.tp ?? \"-\");\n    const tpDisplay = tpBonus > 0 ? `${tpBase} (+${tpBonus})` : tpBase;\n    const atMod = toNum(w.at_mod ?? 0);\n    const paMod = toNum(w.pa_mod ?? 0);\n    const atModStr = atMod === 0 ? \"0\" : (atMod > 0 ? \"+\" + atMod : String(atMod));\n    const paModStr = paMod === 0 ? \"0\" : (paMod > 0 ? \"+\" + paMod : String(paMod));\n    const rw = escapeHtml(w.rw ?? \"-\");\n    const laenge = escapeHtml(w.laenge ?? w.l√§nge ?? \"-\");\n    const gewicht = escapeHtml(w.gewicht ?? \"-\");\n    const tech = techMap[techRaw];\n    const ktw = getKtw(techRaw);\n    const baseAt = ktw + bonusFromAttr(\"mu\") + atMod;\n    let basePa = \"-\";\n    if (tech && tech.parry) {\n        const attrBonus = tech.attrKeys.reduce((max, k) => Math.max(max, bonusFromAttr(k)), 0);\n        basePa = String(Math.ceil(ktw / 2) + attrBonus + paMod);\n    }\n    let rows = `<tr class=\"weapon-main\"><td>${waffe}</td><td>${kampftechnik}</td><td>${lDisplay}</td><td>${sVal}</td><td>${tpDisplay}</td><td>${atModStr}</td><td>${paModStr}</td><td>${rw}</td><td>${laenge}</td><td>${baseAt}</td><td>${basePa}</td><td>${gewicht}</td></tr>`;\n    if (w.waffenvorteil) rows += `<tr class=\"weapon-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Vorteil:</strong> ${escapeHtml(w.waffenvorteil)}</td></tr>`;\n    if (w.waffennachteil) rows += `<tr class=\"weapon-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Nachteil:</strong> ${escapeHtml(w.waffennachteil)}</td></tr>`;\n    return rows;\n}).join(\"\");\nreturn `<table class=\"nahkampfwaffen-table\"><thead><tr><th>Waffe</th><th>Kampftechnik</th><th>L</th><th>S</th><th>TP</th><th>AT Mod.</th><th>PA Mod.</th><th>RW</th><th>L√§nge</th><th>AT</th><th>PA</th><th>Gewicht</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                            }
                          ]
                        }
                      ],
                      "open": true
                    },
                    {
                      "type": "collapse",
                      "id": "2a1bd808ab4a",
                      "heading": "Fernkampfwaffen",
                      "hasRule": false,
                      "conditioned": true,
                      "properties": [
                        "fernkampfwaffen"
                      ],
                      "nested": [
                        {
                          "type": "group",
                          "id": "197bdbda7bfa",
                          "properties": [],
                          "nested": [
                            {
                              "type": "property",
                              "id": "fernkampfwaffen-table",
                              "display": "",
                              "properties": [
                                "fernkampfwaffen"
                              ],
                              "fallback": "",
                              "conditioned": true,
                              "callback": "const weapons = monster.fernkampfwaffen ?? [];\nif (!Array.isArray(weapons) || weapons.length === 0) return \"\";\nconst escapeHtml = str => String(str ?? \"\").replace(/[&<>\"']/g, c => ({ \"&\": \"&amp;\", \"<\": \"&lt;\", \">\": \"&gt;\", '\"': \"&quot;\", \"'\": \"&#39;\" }[c] || c));\nconst toNum = v => { if (typeof v === \"number\") return v; if (typeof v === \"string\") { const p = Number(v.trim()); return Number.isFinite(p) ? p : 0; } return 0; };\nconst toUmlaut = s => s.replace(/oe/g, '√∂').replace(/ae/g, '√§').replace(/ue/g, '√º');\nconst toAscii = s => s.replace(/√∂/g, 'oe').replace(/√§/g, 'ae').replace(/√º/g, 'ue');\nconst attrs = monster.eigenschaften ?? {};\nconst getAttr = k => toNum(attrs[k] ?? monster[k] ?? monster[`eigenschaften.${k}`]);\nconst bonusFromAttr = k => { const v = getAttr(k); return v <= 8 ? 0 : Math.round((v - 8) / 3); };\nconst getKtw = key => {\n    const store = monster.kampftechniken ?? {};\n    const k = key.toLowerCase().replace(/[^a-z√§√∂√º√ü]/g, \"\");\n    if (k in store) return toNum(store[k]);\n    for (const storeKey in store) { if (toUmlaut(storeKey) === k) return toNum(store[storeKey]); }\n    const kAscii = toAscii(k);\n    if (kAscii in store) return toNum(store[kAscii]);\n    for (const storeKey in store) { if (storeKey.toLowerCase() === k || storeKey.toLowerCase() === kAscii) return toNum(store[storeKey]); }\n    if (`kampftechniken.${k}` in monster) return toNum(monster[`kampftechniken.${k}`]);\n    return 6;\n};\nconst cols = 8;\nconst renderRows = () => weapons.map(w => {\n    const waffe = escapeHtml(w.waffe ?? w.name ?? \"-\");\n    const techRaw = String(w.kampftechnik ?? w.technik ?? \"\").toLowerCase().replace(/[^a-z√§√∂√º]/g, \"\");\n    const kampftechnik = escapeHtml(w.kampftechnik ?? w.technik ?? \"-\");\n    const lz = escapeHtml(w.lz ?? \"-\");\n    const tp = escapeHtml(w.tp ?? \"-\");\n    const rw = escapeHtml(w.rw ?? \"-\");\n    const laenge = escapeHtml(w.laenge ?? w.l√§nge ?? \"-\");\n    const gewicht = escapeHtml(w.gewicht ?? \"-\");\n    const ktw = getKtw(techRaw);\n    const fk = ktw + bonusFromAttr(\"ff\");\n    let rows = `<tr class=\"weapon-main\"><td>${waffe}</td><td>${kampftechnik}</td><td>${lz}</td><td>${tp}</td><td>${rw}</td><td>${fk}</td><td>${gewicht}</td><td>${laenge}</td></tr>`;\n    if (w.waffenvorteil) rows += `<tr class=\"weapon-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Vorteil:</strong> ${escapeHtml(w.waffenvorteil)}</td></tr>`;\n    if (w.waffennachteil) rows += `<tr class=\"weapon-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Nachteil:</strong> ${escapeHtml(w.waffennachteil)}</td></tr>`;\n    return rows;\n}).join(\"\");\nreturn `<table class=\"fernkampfwaffen-table\"><thead><tr><th>Waffe</th><th>Kampftechnik</th><th>LZ</th><th>TP</th><th>RW</th><th>FK</th><th>Gewicht</th><th>L√§nge</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                            }
                          ]
                        }
                      ],
                      "open": false
                    },
                    {
                      "type": "collapse",
                      "id": "f9bae909c9e8",
                      "heading": "R√ºstungen",
                      "hasRule": false,
                      "conditioned": true,
                      "properties": [
                        "ruestungen"
                      ],
                      "nested": [
                        {
                          "type": "group",
                          "id": "6a983b3a2bcb",
                          "properties": [],
                          "nested": [
                            {
                              "type": "property",
                              "id": "ruestungen-table",
                              "display": "",
                              "properties": [
                                "ruestungen"
                              ],
                              "fallback": "",
                              "conditioned": true,
                              "callback": "const armor = monster.ruestungen ?? monster.r√ºstungen ?? [];\nif (!Array.isArray(armor) || armor.length === 0) return \"\";\nconst escapeHtml = str => String(str ?? \"\").replace(/[&<>\"']/g, c => ({ \"&\": \"&amp;\", \"<\": \"&lt;\", \">\": \"&gt;\", '\"': \"&quot;\", \"'\": \"&#39;\" }[c] || c));\nconst parseAbzuege = str => { const result = { gs: '-', ini: '-' }; if (!str || str === '-') return result; const gsMatch = String(str).match(/(-?\\d+)\\s*GS/i); const iniMatch = String(str).match(/(-?\\d+)\\s*INI/i); if (gsMatch) result.gs = gsMatch[1]; if (iniMatch) result.ini = iniMatch[1]; return result; };\nconst cols = 6;\nconst renderRows = () => armor.map(a => {\n    const ruestung = escapeHtml(a.ruestung ?? a.r√ºstung ?? a.name ?? \"-\");\n    const rs = escapeHtml(a.rs ?? \"-\");\n    const be = escapeHtml(a.be ?? \"-\");\n    const abzuege = parseAbzuege(a.zusaetzliche_abzuege);\n    const gs = escapeHtml(a.gs ?? abzuege.gs);\n    const ini = escapeHtml(a.ini ?? abzuege.ini);\n    const gewicht = escapeHtml(a.gewicht ?? \"-\");\n    let rows = `<tr class=\"armor-main\"><td>${ruestung}</td><td>${rs}</td><td>${be}</td><td>${gs}</td><td>${ini}</td><td>${gewicht}</td></tr>`;\n    if (a.anmerkung) rows += `<tr class=\"armor-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Anmerkung:</strong> ${escapeHtml(a.anmerkung)}</td></tr>`;\n    if (a.ruestungsvorteil) rows += `<tr class=\"armor-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Vorteil:</strong> ${escapeHtml(a.ruestungsvorteil)}</td></tr>`;\n    if (a.ruestungsnachteil) rows += `<tr class=\"armor-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Nachteil:</strong> ${escapeHtml(a.ruestungsnachteil)}</td></tr>`;\n    return rows;\n}).join(\"\");\nreturn `<table class=\"ruestungen-table\"><thead><tr><th>R√ºstung</th><th>RS</th><th>BE</th><th>GS</th><th>INI</th><th>Gewicht</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                            }
                          ]
                        }
                      ],
                      "open": false
                    }
                  ]
                }
              ],
              "open": true
            }
          ],
          "heading": "Ausr√ºstung"
        },
        {
          "type": "group",
          "id": "talente-lite-section",
          "properties": [
            "talente"
          ],
          "conditioned": true,
          "nested": [
            {
              "type": "collapse",
              "id": "talente-lite-collapse",
              "heading": "",
              "hasRule": false,
              "conditioned": false,
              "nested": [
                {
                  "type": "group",
                  "id": "talente-lite-group",
                  "properties": [],
                  "nested": [
                    {
                      "type": "property",
                      "id": "talente-lite-table",
                      "display": "",
                      "properties": [
                        "talente"
                      ],
                      "fallback": "",
                      "conditioned": false,
                      "callback": "const allTalents = [\n    { key: \"fliegen\", name: \"Fliegen\", attrs: [\"mu\", \"in\", \"ge\"], be: \"Ja\", sf: \"B\", cat: \"K√∂rper\" },\n    { key: \"gaukeleien\", name: \"Gaukeleien\", attrs: [\"mu\", \"ch\", \"ff\"], be: \"Ja\", sf: \"A\", cat: \"K√∂rper\" },\n    { key: \"klettern\", name: \"Klettern\", attrs: [\"mu\", \"ge\", \"kk\"], be: \"Ja\", sf: \"B\", cat: \"K√∂rper\" },\n    { key: \"koerperbeherrschung\", name: \"K√∂rperbeherrschung\", attrs: [\"ge\", \"ge\", \"ko\"], be: \"Ja\", sf: \"D\", cat: \"K√∂rper\" },\n    { key: \"kraftakt\", name: \"Kraftakt\", attrs: [\"ko\", \"kk\", \"kk\"], be: \"Ja\", sf: \"B\", cat: \"K√∂rper\" },\n    { key: \"reiten\", name: \"Reiten\", attrs: [\"ch\", \"ge\", \"kk\"], be: \"Ja\", sf: \"B\", cat: \"K√∂rper\" },\n    { key: \"schwimmen\", name: \"Schwimmen\", attrs: [\"ge\", \"ko\", \"kk\"], be: \"Ja\", sf: \"B\", cat: \"K√∂rper\" },\n    { key: \"selbstbeherrschung\", name: \"Selbstbeherrschung\", attrs: [\"mu\", \"mu\", \"ko\"], be: \"Nein\", sf: \"D\", cat: \"K√∂rper\" },\n    { key: \"singen\", name: \"Singen\", attrs: [\"kl\", \"ch\", \"ko\"], be: \"Evtl\", sf: \"A\", cat: \"K√∂rper\" },\n    { key: \"sinnesschaerfe\", name: \"Sinnessch√§rfe\", attrs: [\"kl\", \"in\", \"in\"], be: \"Evtl\", sf: \"D\", cat: \"K√∂rper\" },\n    { key: \"tanzen\", name: \"Tanzen\", attrs: [\"kl\", \"ch\", \"ge\"], be: \"Ja\", sf: \"A\", cat: \"K√∂rper\" },\n    { key: \"taschendiebstahl\", name: \"Taschendiebstahl\", attrs: [\"mu\", \"ff\", \"ge\"], be: \"Ja\", sf: \"B\", cat: \"K√∂rper\" },\n    { key: \"verbergen\", name: \"Verbergen\", attrs: [\"mu\", \"in\", \"ge\"], be: \"Ja\", sf: \"C\", cat: \"K√∂rper\" },\n    { key: \"zechen\", name: \"Zechen\", attrs: [\"kl\", \"ko\", \"kk\"], be: \"Nein\", sf: \"A\", cat: \"K√∂rper\" },\n    { key: \"bekehren_ueberzeugen\", name: \"Bekehren & √úberzeugen\", attrs: [\"mu\", \"kl\", \"ch\"], be: \"Nein\", sf: \"B\", cat: \"Gesellschaft\" },\n    { key: \"betoeren\", name: \"Bet√∂ren\", attrs: [\"mu\", \"ch\", \"ch\"], be: \"Evtl\", sf: \"B\", cat: \"Gesellschaft\" },\n    { key: \"einschuechtern\", name: \"Einsch√ºchtern\", attrs: [\"mu\", \"in\", \"ch\"], be: \"Nein\", sf: \"B\", cat: \"Gesellschaft\" },\n    { key: \"etikette\", name: \"Etikette\", attrs: [\"kl\", \"in\", \"ch\"], be: \"Nein\", sf: \"B\", cat: \"Gesellschaft\" },\n    { key: \"gassenwissen\", name: \"Gassenwissen\", attrs: [\"kl\", \"in\", \"ch\"], be: \"Evtl\", sf: \"C\", cat: \"Gesellschaft\" },\n    { key: \"menschenkenntnis\", name: \"Menschenkenntnis\", attrs: [\"kl\", \"in\", \"ch\"], be: \"Nein\", sf: \"C\", cat: \"Gesellschaft\" },\n    { key: \"ueberreden\", name: \"√úberreden\", attrs: [\"mu\", \"in\", \"ch\"], be: \"Nein\", sf: \"C\", cat: \"Gesellschaft\" },\n    { key: \"verkleiden\", name: \"Verkleiden\", attrs: [\"in\", \"ch\", \"ge\"], be: \"Ja\", sf: \"B\", cat: \"Gesellschaft\" },\n    { key: \"willenskraft\", name: \"Willenskraft\", attrs: [\"mu\", \"in\", \"ch\"], be: \"Nein\", sf: \"D\", cat: \"Gesellschaft\" },\n    { key: \"faehrtensuchen\", name: \"F√§hrtensuchen\", attrs: [\"mu\", \"in\", \"ge\"], be: \"Ja\", sf: \"C\", cat: \"Natur\" },\n    { key: \"fesseln\", name: \"Fesseln\", attrs: [\"kl\", \"ff\", \"kk\"], be: \"Evtl\", sf: \"A\", cat: \"Natur\" },\n    { key: \"fischen_angeln\", name: \"Fischen & Angeln\", attrs: [\"ff\", \"ge\", \"ko\"], be: \"Evtl\", sf: \"A\", cat: \"Natur\" },\n    { key: \"orientierung\", name: \"Orientierung\", attrs: [\"kl\", \"in\", \"in\"], be: \"Nein\", sf: \"B\", cat: \"Natur\" },\n    { key: \"pflanzenkunde\", name: \"Pflanzenkunde\", attrs: [\"kl\", \"ff\", \"ko\"], be: \"Evtl\", sf: \"C\", cat: \"Natur\" },\n    { key: \"tierkunde\", name: \"Tierkunde\", attrs: [\"mu\", \"mu\", \"ch\"], be: \"Ja\", sf: \"C\", cat: \"Natur\" },\n    { key: \"wildnisleben\", name: \"Wildnisleben\", attrs: [\"mu\", \"ge\", \"ko\"], be: \"Ja\", sf: \"C\", cat: \"Natur\" },\n    { key: \"brett_gluecksspiel\", name: \"Brett- & Gl√ºcksspiel\", attrs: [\"kl\", \"kl\", \"in\"], be: \"Nein\", sf: \"A\", cat: \"Wissen\" },\n    { key: \"geographie\", name: \"Geographie\", attrs: [\"kl\", \"kl\", \"in\"], be: \"Nein\", sf: \"B\", cat: \"Wissen\" },\n    { key: \"geschichtswissen\", name: \"Geschichtswissen\", attrs: [\"kl\", \"kl\", \"in\"], be: \"Nein\", sf: \"B\", cat: \"Wissen\" },\n    { key: \"goetter_kulte\", name: \"G√∂tter & Kulte\", attrs: [\"kl\", \"kl\", \"in\"], be: \"Nein\", sf: \"B\", cat: \"Wissen\" },\n    { key: \"kriegskunst\", name: \"Kriegskunst\", attrs: [\"mu\", \"kl\", \"in\"], be: \"Nein\", sf: \"B\", cat: \"Wissen\" },\n    { key: \"magiekunde\", name: \"Magiekunde\", attrs: [\"kl\", \"kl\", \"in\"], be: \"Nein\", sf: \"C\", cat: \"Wissen\" },\n    { key: \"mechanik\", name: \"Mechanik\", attrs: [\"kl\", \"kl\", \"ff\"], be: \"Nein\", sf: \"B\", cat: \"Wissen\" },\n    { key: \"rechnen\", name: \"Rechnen\", attrs: [\"kl\", \"kl\", \"in\"], be: \"Nein\", sf: \"A\", cat: \"Wissen\" },\n    { key: \"rechtskunde\", name: \"Rechtskunde\", attrs: [\"kl\", \"kl\", \"in\"], be: \"Nein\", sf: \"A\", cat: \"Wissen\" },\n    { key: \"sagen_legenden\", name: \"Sagen & Legenden\", attrs: [\"kl\", \"kl\", \"in\"], be: \"Nein\", sf: \"B\", cat: \"Wissen\" },\n    { key: \"sphaerenkunde\", name: \"Sph√§renkunde\", attrs: [\"kl\", \"kl\", \"in\"], be: \"Nein\", sf: \"B\", cat: \"Wissen\" },\n    { key: \"sternkunde\", name: \"Sternkunde\", attrs: [\"kl\", \"kl\", \"in\"], be: \"Nein\", sf: \"A\", cat: \"Wissen\" },\n    { key: \"alchimie\", name: \"Alchimie\", attrs: [\"mu\", \"kl\", \"ff\"], be: \"Ja\", sf: \"C\", cat: \"Handwerk\" },\n    { key: \"boote_schiffe\", name: \"Boote & Schiffe\", attrs: [\"ff\", \"ge\", \"kk\"], be: \"Ja\", sf: \"B\", cat: \"Handwerk\" },\n    { key: \"fahrzeuge\", name: \"Fahrzeuge\", attrs: [\"ch\", \"ff\", \"ko\"], be: \"Ja\", sf: \"A\", cat: \"Handwerk\" },\n    { key: \"handel\", name: \"Handel\", attrs: [\"kl\", \"in\", \"ch\"], be: \"Nein\", sf: \"B\", cat: \"Handwerk\" },\n    { key: \"heilkunde_gift\", name: \"Heilkunde Gift\", attrs: [\"mu\", \"kl\", \"in\"], be: \"Ja\", sf: \"B\", cat: \"Handwerk\" },\n    { key: \"heilkunde_krankheiten\", name: \"Heilkunde Krankheiten\", attrs: [\"mu\", \"in\", \"ko\"], be: \"Ja\", sf: \"B\", cat: \"Handwerk\" },\n    { key: \"heilkunde_seele\", name: \"Heilkunde Seele\", attrs: [\"in\", \"ch\", \"ko\"], be: \"Nein\", sf: \"B\", cat: \"Handwerk\" },\n    { key: \"heilkunde_wunden\", name: \"Heilkunde Wunden\", attrs: [\"kl\", \"ff\", \"ff\"], be: \"Ja\", sf: \"D\", cat: \"Handwerk\" },\n    { key: \"holzbearbeitung\", name: \"Holzbearbeitung\", attrs: [\"ff\", \"ge\", \"kk\"], be: \"Ja\", sf: \"B\", cat: \"Handwerk\" },\n    { key: \"lebensmittelbearbeitung\", name: \"Lebensmittelbearbeitung\", attrs: [\"in\", \"ff\", \"ff\"], be: \"Ja\", sf: \"A\", cat: \"Handwerk\" },\n    { key: \"lederbearbeitung\", name: \"Lederbearbeitung\", attrs: [\"ff\", \"ge\", \"ko\"], be: \"Ja\", sf: \"B\", cat: \"Handwerk\" },\n    { key: \"malen_zeichnen\", name: \"Malen & Zeichnen\", attrs: [\"in\", \"ff\", \"ff\"], be: \"Ja\", sf: \"A\", cat: \"Handwerk\" },\n    { key: \"metallbearbeitung\", name: \"Metallbearbeitung\", attrs: [\"ff\", \"ko\", \"kk\"], be: \"Ja\", sf: \"C\", cat: \"Handwerk\" },\n    { key: \"musizieren\", name: \"Musizieren\", attrs: [\"ch\", \"ff\", \"ko\"], be: \"Ja\", sf: \"A\", cat: \"Handwerk\" },\n    { key: \"schloesserknacken\", name: \"Schl√∂sserknacken\", attrs: [\"in\", \"ff\", \"ff\"], be: \"Ja\", sf: \"C\", cat: \"Handwerk\" },\n    { key: \"steinbearbeitung\", name: \"Steinbearbeitung\", attrs: [\"ff\", \"ff\", \"kk\"], be: \"Ja\", sf: \"A\", cat: \"Handwerk\" },\n    { key: \"stoffbearbeitung\", name: \"Stoffbearbeitung\", attrs: [\"kl\", \"ff\", \"ff\"], be: \"Ja\", sf: \"A\", cat: \"Handwerk\" }\n];\nconst attrNames = { mu: \"MU\", kl: \"KL\", in: \"IN\", ch: \"CH\", ff: \"FF\", ge: \"GE\", ko: \"KO\", kk: \"KK\" };\nconst toValue = v => { if (v == null) return 0; if (typeof v === \"number\") return v; if (typeof v === \"string\") { const p = Number(v.trim()); return Number.isNaN(p) ? 0 : p; } if (typeof v === \"object\" && \"fw\" in v) return toValue(v.fw); return 0; };\nconst getAttr = k => { const a = monster.eigenschaften ?? {}; return toValue(a[k] ?? monster[k] ?? monster[`eigenschaften.${k}`]); };\nconst getFW = k => { const s = monster.talente ?? {}; if (k in s) return toValue(s[k]); if (`talente.${k}` in monster) return toValue(monster[`talente.${k}`]); return 0; };\nconst getMod = k => { const m = monster.talente_mod ?? {}; if (k in m) return toValue(m[k]); if (`talente_mod.${k}` in monster) return toValue(monster[`talente_mod.${k}`]); return 0; };\nconst probeStr = a => a.map(x => attrNames[x] || x.toUpperCase()).join(\"/\");\nconst filtered = allTalents.filter(t => getFW(t.key) > 0);\nif (filtered.length === 0) return '<em style=\"color:var(--property-name-font-color);\">Keine Talente mit FW > 0</em>';\nconst renderRows = () => filtered.map(t => { const fw = getFW(t.key); const mod = getMod(t.key); const modStr = mod === 0 ? \"0\" : (mod > 0 ? \"+\" + mod : String(mod)); const pd = probeStr(t.attrs); const av = t.attrs.map(a => getAttr(a) + mod); const al = t.attrs.map(a => attrNames[a] || a.toUpperCase()); const ts = av.map((v, i) => `${al[i]}:${v}`).join(\" / \"); return `<tr><td>${t.name}</td><td>${t.cat}</td><td class=\"talent-probe\"><strong>${pd}</strong><br/><small>${ts}</small></td><td>${modStr}</td><td>${t.be}</td><td>${t.sf}</td><td>${fw}</td></tr>`; }).join(\"\");\nreturn `<table class=\"talent-table\"><thead><tr><th>Talent</th><th>Kategorie</th><th>Probe (Zielwerte)</th><th>Mod.</th><th>BE</th><th>Sf.</th><th>Fw</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                    }
                  ]
                }
              ],
              "open": true
            }
          ],
          "heading": "Talente",
          "hasRule": false
        },
        {
          "type": "group",
          "id": "kampftechniken-lite-section",
          "properties": [
            "kampftechniken"
          ],
          "conditioned": true,
          "nested": [
            {
              "type": "collapse",
              "id": "kampftechniken-lite-collapse",
              "heading": "",
              "hasRule": false,
              "conditioned": false,
              "nested": [
                {
                  "type": "group",
                  "id": "kampftechniken-lite-group",
                  "properties": [],
                  "nested": [
                    {
                      "type": "property",
                      "id": "kampftechnik-lite-table",
                      "display": "",
                      "properties": [
                        "kampftechniken"
                      ],
                      "fallback": "",
                      "conditioned": false,
                      "callback": "const techniques = [\n    { key: \"armbrueste\", name: \"Armbr√ºste\", attrLabel: \"FF\", attrKeys: [\"ff\"], sf: \"B\", ranged: true, parry: false },\n    { key: \"boegen\", name: \"B√∂gen\", attrLabel: \"FF\", attrKeys: [\"ff\"], sf: \"C\", ranged: true, parry: false },\n    { key: \"dolche\", name: \"Dolche\", attrLabel: \"GE\", attrKeys: [\"ge\"], sf: \"B\", ranged: false, parry: true },\n    { key: \"fechtwaffen\", name: \"Fechtwaffen\", attrLabel: \"GE\", attrKeys: [\"ge\"], sf: \"C\", ranged: false, parry: true },\n    { key: \"hiebwaffen\", name: \"Hiebwaffen\", attrLabel: \"KK\", attrKeys: [\"kk\"], sf: \"C\", ranged: false, parry: true },\n    { key: \"kettenwaffen\", name: \"Kettenwaffen\", attrLabel: \"KK\", attrKeys: [\"kk\"], sf: \"C\", ranged: false, parry: false },\n    { key: \"lanzen\", name: \"Lanzen\", attrLabel: \"KK\", attrKeys: [\"kk\"], sf: \"B\", ranged: false, parry: true },\n    { key: \"raufen\", name: \"Raufen\", attrLabel: \"GE/KK\", attrKeys: [\"ge\", \"kk\"], sf: \"B\", ranged: false, parry: true },\n    { key: \"schilde\", name: \"Schilde\", attrLabel: \"KK\", attrKeys: [\"kk\"], sf: \"C\", ranged: false, parry: true },\n    { key: \"schwerter\", name: \"Schwerter\", attrLabel: \"GE/KK\", attrKeys: [\"ge\", \"kk\"], sf: \"C\", ranged: false, parry: true },\n    { key: \"stangenwaffen\", name: \"Stangenwaffen\", attrLabel: \"GE/KK\", attrKeys: [\"ge\", \"kk\"], sf: \"C\", ranged: false, parry: true },\n    { key: \"wurfwafen\", name: \"Wurfwafen\", attrLabel: \"FF\", attrKeys: [\"ff\"], sf: \"B\", ranged: true, parry: false },\n    { key: \"zweihandhiebwaffen\", name: \"Zweihandhiebwaffen\", attrLabel: \"KK\", attrKeys: [\"kk\"], sf: \"C\", ranged: false, parry: true },\n    { key: \"zweihandschwerter\", name: \"Zweihandschwerter\", attrLabel: \"KK\", attrKeys: [\"kk\"], sf: \"C\", ranged: false, parry: true }\n];\nconst escapeHtml = str => (str ?? \"\").replace(/[&<>\"']/g, c => ({ \"&\": \"&amp;\", \"<\": \"&lt;\", \">\": \"&gt;\", '\"': \"&quot;\", \"'\": \"&#39;\" }[c] || c));\nconst toNumber = value => {\n    if (typeof value === \"number\") return value;\n    if (typeof value === \"string\") { const parsed = Number(value.trim()); return Number.isFinite(parsed) ? parsed : NaN; }\n    return NaN;\n};\nconst toValue = value => {\n    if (value === undefined || value === null) return null;\n    if (typeof value === \"object\" && \"ktw\" in value) return toValue(value.ktw);\n    const num = toNumber(value);\n    return Number.isFinite(num) ? num : null;\n};\nconst toUmlaut = s => s.replace(/oe/g, '√∂').replace(/ae/g, '√§').replace(/ue/g, '√º');\nconst toAscii = s => s.replace(/√∂/g, 'oe').replace(/√§/g, 'ae').replace(/√º/g, 'ue');\nconst getKtw = key => {\n    const store = monster.kampftechniken ?? {};\n    if (key in store) { const val = toValue(store[key]); if (Number.isFinite(val)) return val; }\n    const keyUmlaut = toUmlaut(key);\n    if (keyUmlaut in store) { const val = toValue(store[keyUmlaut]); if (Number.isFinite(val)) return val; }\n    for (const storeKey in store) { if (storeKey.toLowerCase() === key || toAscii(storeKey.toLowerCase()) === key || toUmlaut(storeKey.toLowerCase()) === keyUmlaut) { const val = toValue(store[storeKey]); if (Number.isFinite(val)) return val; } }\n    const nestedKey = `kampftechniken.${key}`;\n    if (nestedKey in monster) { const val = toValue(monster[nestedKey]); if (Number.isFinite(val)) return val; }\n    if (key in monster) { const val = toValue(monster[key]); if (Number.isFinite(val)) return val; }\n    return 6;\n};\nconst attrs = monster.eigenschaften ?? {};\nconst getAttr = key => toNumber(attrs[key] ?? monster[key] ?? monster[`eigenschaften.${key}`]);\nconst bonusFromAttr = key => { const val = getAttr(key); if (!Number.isFinite(val) || val <= 8) return 0; return Math.round((val - 8) / 3); };\nconst calcAt = ktw => ktw + bonusFromAttr(\"mu\");\nconst calcFk = ktw => ktw + bonusFromAttr(\"ff\");\nconst calcPa = (ktw, attrKeys) => { if (!attrKeys.length) return NaN; const attrBonus = attrKeys.reduce((max, key) => Math.max(max, bonusFromAttr(key)), 0); return Math.ceil(ktw / 2) + attrBonus; };\nconst renderCheck = value => !Number.isFinite(value) ? \"-\" : String(value);\nconst filtered = techniques.filter(tech => getKtw(tech.key) > 6);\nif (filtered.length === 0) return '<em style=\"color:var(--property-name-font-color);\">Keine Kampftechniken mit KTW > 6</em>';\nconst renderRows = () => filtered.map(tech => {\n    const raw = getKtw(tech.key);\n    const ktw = Number.isFinite(raw) ? raw : 6;\n    const atkValue = tech.ranged ? calcFk(ktw) : calcAt(ktw);\n    const paValue = tech.parry ? calcPa(ktw, tech.attrKeys) : NaN;\n    const atkLabel = tech.ranged ? \"FK\" : \"AT\";\n    const atkCell = renderCheck(atkValue);\n    const paCell = tech.parry ? renderCheck(paValue) : \"-\";\n    const safeName = escapeHtml(tech.name);\n    const safeAttr = escapeHtml(tech.attrLabel);\n    const safeSf = escapeHtml(tech.sf);\n    return `<tr><td>${safeName}</td><td>${safeAttr}</td><td>${safeSf}</td><td>${ktw}</td><td>${atkCell}</td><td>${paCell}</td></tr>`;\n}).join(\"\");\nreturn `<table class=\"kampftechnik-table\"><thead><tr><th>Kampftechnik</th><th>Leiteig.</th><th>Sf.</th><th>Ktw.</th><th>AT/FK</th><th>PA</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                    }
                  ]
                }
              ],
              "open": true
            }
          ],
          "heading": "Kampftechniken",
          "hasRule": false
        },
        {
          "type": "group",
          "id": "magie-section",
          "properties": [
            "zauber",
            "rituale",
            "zaubertricks"
          ],
          "conditioned": true,
          "nested": [
            {
              "type": "collapse",
              "id": "zauber-collapse",
              "heading": "Zauber",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "zauber-table",
                  "display": "",
                  "properties": [
                    "zauber"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const spells = monster.zauber ?? [];\nif (!Array.isArray(spells) || spells.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 9;\nconst renderRows = () => spells.map(s => {\n  let rows = `<tr class=\"spell-main\"><td>${esc(s.name)}</td><td>${esc(s.probe)}</td><td>${esc(s.zauberdauer)}</td><td>${esc(s.asp)}</td><td>${esc(s.rw)}</td><td>${esc(s.wirkungsdauer)}</td><td>${esc(s.merkmal)}</td><td>${esc(s.sf)}</td><td>${esc(s.fw ?? '0')}</td></tr>`;\n  if (s.wirkung) rows += `<tr class=\"spell-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Wirkung:</strong> ${esc(s.wirkung)}</td></tr>`;\n  if (s.reversalis) rows += `<tr class=\"spell-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;font-style:italic;\"><strong>Reversalis:</strong> ${esc(s.reversalis)}</td></tr>`;\n  const erw = s.erweiterungen ?? [];\n  erw.forEach((e, i) => { const txt = typeof e === 'object' ? (e.name ? `${e.name}: ${e.beschreibung ?? ''}` : JSON.stringify(e)) : e; rows += `<tr class=\"spell-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.85em;\"><strong>Erw. ${i+1}:</strong> ${esc(txt)}</td></tr>`; });\n  return rows;\n}).join('');\nreturn `<table class=\"zauber-table\"><thead><tr><th>Zauber</th><th>Probe</th><th>Zauberdauer</th><th>AsP-Kosten</th><th>RW</th><th>Wirkungsdauer</th><th>Merkmal</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            },
            {
              "type": "collapse",
              "id": "rituale-collapse",
              "heading": "Rituale",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "rituale-table",
                  "display": "",
                  "properties": [
                    "rituale"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const rituals = monster.rituale ?? [];\nif (!Array.isArray(rituals) || rituals.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 9;\nconst renderRows = () => rituals.map(r => {\n  let rows = `<tr class=\"spell-main\"><td>${esc(r.name)}</td><td>${esc(r.probe)}</td><td>${esc(r.ritualdauer)}</td><td>${esc(r.asp)}</td><td>${esc(r.rw)}</td><td>${esc(r.wirkungsdauer)}</td><td>${esc(r.merkmal)}</td><td>${esc(r.sf)}</td><td>${esc(r.fw ?? '0')}</td></tr>`;\n  if (r.wirkung) rows += `<tr class=\"spell-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Wirkung:</strong> ${esc(r.wirkung)}</td></tr>`;\n  if (r.reversalis) rows += `<tr class=\"spell-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;font-style:italic;\"><strong>Reversalis:</strong> ${esc(r.reversalis)}</td></tr>`;\n  const erw = r.erweiterungen ?? [];\n  erw.forEach((e, i) => { const txt = typeof e === 'object' ? (e.name ? `${e.name}: ${e.beschreibung ?? ''}` : JSON.stringify(e)) : e; rows += `<tr class=\"spell-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.85em;\"><strong>Erw. ${i+1}:</strong> ${esc(txt)}</td></tr>`; });\n  return rows;\n}).join('');\nreturn `<table class=\"rituale-table\"><thead><tr><th>Ritual</th><th>Probe</th><th>Ritualdauer</th><th>AsP-Kosten</th><th>RW</th><th>Wirkungsdauer</th><th>Merkmal</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            },
            {
              "type": "collapse",
              "id": "zaubertricks-collapse",
              "heading": "Zaubertricks",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "zaubertricks-table",
                  "display": "",
                  "properties": [
                    "zaubertricks"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const tricks = monster.zaubertricks ?? [];\nif (!Array.isArray(tricks) || tricks.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 9;\nconst renderRows = () => tricks.map(t => {\n  let rows = `<tr class=\"spell-main\"><td>${esc(t.name)}</td><td>${esc(t.probe)}</td><td>${esc(t.zauberdauer)}</td><td>${esc(t.asp)}</td><td>${esc(t.rw)}</td><td>${esc(t.wirkungsdauer)}</td><td>${esc(t.merkmal)}</td><td>${esc(t.sf)}</td><td>${esc(t.fw ?? '0')}</td></tr>`;\n  if (t.wirkung) rows += `<tr class=\"spell-detail\"><td colspan=\"${cols}\"><strong>Wirkung:</strong> ${esc(t.wirkung)}</td></tr>`;\n  const erw = t.erweiterungen ?? [];\n  erw.forEach((e, i) => { rows += `<tr class=\"spell-detail\"><td colspan=\"${cols}\"><strong>Erweiterung ${i+1}:</strong> ${esc(e)}</td></tr>`; });\n  return rows;\n}).join('');\nreturn `<table class=\"zaubertricks-table\"><thead><tr><th>Zaubertrick</th><th>Probe</th><th>Zauberdauer</th><th>AsP-Kosten</th><th>RW</th><th>Wirkungsdauer</th><th>Merkmal</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            }
          ],
          "heading": "Magie",
          "hasRule": false
        },
        {
          "type": "group",
          "id": "magische-handlungen-section",
          "properties": [
            "magische_handlungen",
            "elfenlieder",
            "hexenfluche",
            "zaubertanze",
            "zaubermelodien",
            "zauberrunen",
            "schelmenstreiche",
            "animistenkraefte",
            "geodenrituale",
            "herrschaftsrituale",
            "zibiljarituale",
            "goblinrituale",
            "bannzeichen"
          ],
          "conditioned": true,
          "nested": [
            {
              "type": "collapse",
              "id": "magische-handlungen-generic-collapse",
              "heading": "Allgemeine Magische Handlungen",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "magische-handlungen-generic-table",
                  "display": "",
                  "properties": [
                    "magische_handlungen"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const items = monster.magische_handlungen ?? [];\nif (!Array.isArray(items) || items.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 7;\nconst renderRows = () => items.map(h => {\n  let rows = `<tr class=\"mh-main\"><td>${esc(h.name)}</td><td>${esc(h.typ ?? '-')}</td><td>${esc(h.probe)}</td><td>${esc(h.dauer ?? '-')}</td><td>${esc(h.asp)}</td><td>${esc(h.merkmal)}</td><td>${esc(h.sf ?? '-')}</td></tr>`;\n  if (h.wirkung) rows += `<tr class=\"mh-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Wirkung:</strong> ${esc(h.wirkung)}</td></tr>`;\n  return rows;\n}).join('');\nreturn `<table class=\"mh-table\"><thead><tr><th>Name</th><th>Typ</th><th>Probe</th><th>Dauer</th><th>AsP</th><th>Merkmal</th><th>Sf.</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            },
            {
              "type": "collapse",
              "id": "elfenlieder-collapse",
              "heading": "Elfenlieder",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "elfenlieder-table",
                  "display": "",
                  "properties": [
                    "elfenlieder"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const items = monster.elfenlieder ?? [];\nif (!Array.isArray(items) || items.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 7;\nconst renderRows = () => items.map(h => {\n  let rows = `<tr class=\"mh-main\"><td>${esc(h.name)}</td><td>${esc(h.probe)}</td><td>${esc(h.dauer ?? h.talent)}</td><td>${esc(h.asp)}</td><td>${esc(h.merkmal)}</td><td>${esc(h.sf)}</td><td>${esc(h.fw ?? '0')}</td></tr>`;\n  if (h.wirkung) rows += `<tr class=\"mh-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Wirkung:</strong> ${esc(h.wirkung)}</td></tr>`;\n  return rows;\n}).join('');\nreturn `<table class=\"mh-table\"><thead><tr><th>Elfenlied</th><th>Probe</th><th>Dauer</th><th>AsP</th><th>Merkmal</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            },
            {
              "type": "collapse",
              "id": "hexenfluche-collapse",
              "heading": "Hexenfl√ºche",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "hexenfluche-table",
                  "display": "",
                  "properties": [
                    "hexenfluche"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const items = monster.hexenfluche ?? [];\nif (!Array.isArray(items) || items.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 7;\nconst renderRows = () => items.map(h => {\n  let rows = `<tr class=\"mh-main\"><td>${esc(h.name)}</td><td>${esc(h.probe)}</td><td>${esc(h.dauer ?? h.talent)}</td><td>${esc(h.asp)}</td><td>${esc(h.merkmal)}</td><td>${esc(h.sf)}</td><td>${esc(h.fw ?? '0')}</td></tr>`;\n  if (h.wirkung) rows += `<tr class=\"mh-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Wirkung:</strong> ${esc(h.wirkung)}</td></tr>`;\n  return rows;\n}).join('');\nreturn `<table class=\"mh-table\"><thead><tr><th>Hexenfluch</th><th>Probe</th><th>Dauer</th><th>AsP</th><th>Merkmal</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            },
            {
              "type": "collapse",
              "id": "zaubertanze-collapse",
              "heading": "Zaubert√§nze",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "zaubertanze-table",
                  "display": "",
                  "properties": [
                    "zaubertanze"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const items = monster.zaubertanze ?? [];\nif (!Array.isArray(items) || items.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 7;\nconst renderRows = () => items.map(h => {\n  let rows = `<tr class=\"mh-main\"><td>${esc(h.name)}</td><td>${esc(h.probe)}</td><td>${esc(h.dauer ?? h.talent)}</td><td>${esc(h.asp)}</td><td>${esc(h.merkmal)}</td><td>${esc(h.sf)}</td><td>${esc(h.fw ?? '0')}</td></tr>`;\n  if (h.wirkung) rows += `<tr class=\"mh-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Wirkung:</strong> ${esc(h.wirkung)}</td></tr>`;\n  return rows;\n}).join('');\nreturn `<table class=\"mh-table\"><thead><tr><th>Zaubertanz</th><th>Probe</th><th>Dauer</th><th>AsP</th><th>Merkmal</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            },
            {
              "type": "collapse",
              "id": "zaubermelodien-collapse",
              "heading": "Zaubermelodien",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "zaubermelodien-table",
                  "display": "",
                  "properties": [
                    "zaubermelodien"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const items = monster.zaubermelodien ?? [];\nif (!Array.isArray(items) || items.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 7;\nconst renderRows = () => items.map(h => {\n  let rows = `<tr class=\"mh-main\"><td>${esc(h.name)}</td><td>${esc(h.probe)}</td><td>${esc(h.dauer ?? h.talent)}</td><td>${esc(h.asp)}</td><td>${esc(h.merkmal)}</td><td>${esc(h.sf)}</td><td>${esc(h.fw ?? '0')}</td></tr>`;\n  if (h.wirkung) rows += `<tr class=\"mh-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Wirkung:</strong> ${esc(h.wirkung)}</td></tr>`;\n  return rows;\n}).join('');\nreturn `<table class=\"mh-table\"><thead><tr><th>Zaubermelodie</th><th>Probe</th><th>Dauer</th><th>AsP</th><th>Merkmal</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            },
            {
              "type": "collapse",
              "id": "zauberrunen-collapse",
              "heading": "Zauberrunen",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "zauberrunen-table",
                  "display": "",
                  "properties": [
                    "zauberrunen"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const items = monster.zauberrunen ?? [];\nif (!Array.isArray(items) || items.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 7;\nconst renderRows = () => items.map(h => {\n  let rows = `<tr class=\"mh-main\"><td>${esc(h.name)}</td><td>${esc(h.probe)}</td><td>${esc(h.dauer ?? h.talent)}</td><td>${esc(h.asp)}</td><td>${esc(h.merkmal)}</td><td>${esc(h.sf)}</td><td>${esc(h.fw ?? '0')}</td></tr>`;\n  if (h.wirkung) rows += `<tr class=\"mh-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Wirkung:</strong> ${esc(h.wirkung)}</td></tr>`;\n  return rows;\n}).join('');\nreturn `<table class=\"mh-table\"><thead><tr><th>Zauberrune</th><th>Probe</th><th>Dauer</th><th>AsP</th><th>Merkmal</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            },
            {
              "type": "collapse",
              "id": "schelmenstreiche-collapse",
              "heading": "Schelmenstreiche",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "schelmenstreiche-table",
                  "display": "",
                  "properties": [
                    "schelmenstreiche"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const items = monster.schelmenstreiche ?? [];\nif (!Array.isArray(items) || items.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 7;\nconst renderRows = () => items.map(h => {\n  let rows = `<tr class=\"mh-main\"><td>${esc(h.name)}</td><td>${esc(h.probe)}</td><td>${esc(h.dauer ?? h.talent)}</td><td>${esc(h.asp)}</td><td>${esc(h.merkmal)}</td><td>${esc(h.sf)}</td><td>${esc(h.fw ?? '0')}</td></tr>`;\n  if (h.wirkung) rows += `<tr class=\"mh-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Wirkung:</strong> ${esc(h.wirkung)}</td></tr>`;\n  return rows;\n}).join('');\nreturn `<table class=\"mh-table\"><thead><tr><th>Schelmenstreich</th><th>Probe</th><th>Dauer</th><th>AsP</th><th>Merkmal</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            },
            {
              "type": "collapse",
              "id": "animistenkraefte-collapse",
              "heading": "Animistenkr√§fte",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "animistenkraefte-table",
                  "display": "",
                  "properties": [
                    "animistenkraefte"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const items = monster.animistenkraefte ?? [];\nif (!Array.isArray(items) || items.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 7;\nconst renderRows = () => items.map(h => {\n  let rows = `<tr class=\"mh-main\"><td>${esc(h.name)}</td><td>${esc(h.probe)}</td><td>${esc(h.dauer ?? h.talent)}</td><td>${esc(h.asp)}</td><td>${esc(h.merkmal)}</td><td>${esc(h.sf)}</td><td>${esc(h.fw ?? '0')}</td></tr>`;\n  if (h.wirkung) rows += `<tr class=\"mh-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Wirkung:</strong> ${esc(h.wirkung)}</td></tr>`;\n  return rows;\n}).join('');\nreturn `<table class=\"mh-table\"><thead><tr><th>Animistenkraft</th><th>Probe</th><th>Dauer</th><th>AsP</th><th>Merkmal</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            }
          ],
          "heading": "Magische Handlungen",
          "hasRule": false
        },
        {
          "type": "group",
          "id": "karma-section",
          "properties": [
            "liturgien",
            "zeremonien",
            "segnungen"
          ],
          "conditioned": true,
          "nested": [
            {
              "type": "collapse",
              "id": "liturgien-collapse",
              "heading": "Liturgien",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "liturgien-table",
                  "display": "",
                  "properties": [
                    "liturgien"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const liturgies = monster.liturgien ?? [];\nif (!Array.isArray(liturgies) || liturgies.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 9;\nconst renderRows = () => liturgies.map(l => {\n  let rows = `<tr class=\"spell-main\"><td>${esc(l.name)}</td><td>${esc(l.probe)}</td><td>${esc(l.liturgiedauer)}</td><td>${esc(l.kap)}</td><td>${esc(l.rw)}</td><td>${esc(l.wirkungsdauer)}</td><td>${esc(l.verbreitung ?? l.aspekt)}</td><td>${esc(l.sf)}</td><td>${esc(l.fw ?? '0')}</td></tr>`;\n  if (l.wirkung) rows += `<tr class=\"spell-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Wirkung:</strong> ${esc(l.wirkung)}</td></tr>`;\n  const erw = l.erweiterungen ?? [];\n  erw.forEach((e, i) => { const txt = typeof e === 'object' ? (e.name ? `${e.name}: ${e.beschreibung ?? ''}` : JSON.stringify(e)) : e; rows += `<tr class=\"spell-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.85em;\"><strong>Erw. ${i+1}:</strong> ${esc(txt)}</td></tr>`; });\n  return rows;\n}).join('');\nreturn `<table class=\"liturgien-table\"><thead><tr><th>Liturgie</th><th>Probe</th><th>Liturgiedauer</th><th>KaP-Kosten</th><th>RW</th><th>Wirkungsdauer</th><th>Verbreitung</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            },
            {
              "type": "collapse",
              "id": "zeremonien-collapse",
              "heading": "Zeremonien",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "zeremonien-table",
                  "display": "",
                  "properties": [
                    "zeremonien"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const ceremonies = monster.zeremonien ?? [];\nif (!Array.isArray(ceremonies) || ceremonies.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 9;\nconst renderRows = () => ceremonies.map(c => {\n  let rows = `<tr class=\"spell-main\"><td>${esc(c.name)}</td><td>${esc(c.probe)}</td><td>${esc(c.zeremoniedauer)}</td><td>${esc(c.kap)}</td><td>${esc(c.rw)}</td><td>${esc(c.wirkungsdauer)}</td><td>${esc(c.verbreitung ?? c.aspekt)}</td><td>${esc(c.sf)}</td><td>${esc(c.fw ?? '0')}</td></tr>`;\n  if (c.wirkung) rows += `<tr class=\"spell-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Wirkung:</strong> ${esc(c.wirkung)}</td></tr>`;\n  const erw = c.erweiterungen ?? [];\n  erw.forEach((e, i) => { const txt = typeof e === 'object' ? (e.name ? `${e.name}: ${e.beschreibung ?? ''}` : JSON.stringify(e)) : e; rows += `<tr class=\"spell-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.85em;\"><strong>Erw. ${i+1}:</strong> ${esc(txt)}</td></tr>`; });\n  return rows;\n}).join('');\nreturn `<table class=\"zeremonien-table\"><thead><tr><th>Zeremonie</th><th>Probe</th><th>Zeremoniedauer</th><th>KaP-Kosten</th><th>RW</th><th>Wirkungsdauer</th><th>Verbreitung</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            },
            {
              "type": "collapse",
              "id": "segnungen-collapse",
              "heading": "Segnungen",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "segnungen-table",
                  "display": "",
                  "properties": [
                    "segnungen"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const blessings = monster.segnungen ?? [];\nif (!Array.isArray(blessings) || blessings.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 9;\nconst renderRows = () => blessings.map(b => {\n  let rows = `<tr class=\"spell-main\"><td>${esc(b.name)}</td><td>${esc(b.probe)}</td><td>${esc(b.dauer)}</td><td>${esc(b.kap)}</td><td>${esc(b.rw)}</td><td>${esc(b.wirkungsdauer)}</td><td>${esc(b.aspekt)}</td><td>${esc(b.sf)}</td><td>${esc(b.fw ?? '0')}</td></tr>`;\n  if (b.wirkung) rows += `<tr class=\"spell-detail\"><td colspan=\"${cols}\"><strong>Wirkung:</strong> ${esc(b.wirkung)}</td></tr>`;\n  const erw = b.erweiterungen ?? [];\n  erw.forEach((e, i) => { rows += `<tr class=\"spell-detail\"><td colspan=\"${cols}\"><strong>Erweiterung ${i+1}:</strong> ${esc(e)}</td></tr>`; });\n  return rows;\n}).join('');\nreturn `<table class=\"segnungen-table\"><thead><tr><th>Segnung</th><th>Probe</th><th>Dauer</th><th>KaP-Kosten</th><th>RW</th><th>Wirkungsdauer</th><th>Aspekt</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            }
          ],
          "heading": "G√∂ttliches Wirken",
          "hasRule": false
        },
        {
          "type": "group",
          "id": "vorteile-section",
          "properties": [
            "vorteile"
          ],
          "conditioned": true,
          "nested": [
            {
              "type": "collapse",
              "id": "vorteile-collapse",
              "heading": "",
              "hasRule": false,
              "conditioned": false,
              "nested": [
                {
                  "type": "property",
                  "id": "vorteile-table",
                  "display": "",
                  "properties": [
                    "vorteile"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const items = monster.vorteile ?? [];\nif (!Array.isArray(items) || items.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst renderRows = () => items.map(v => {\n  let rows = `<tr><td><strong>${esc(v.name)}</strong></td><td>${esc(v.ap)}</td></tr>`;\n  if (v.regel) rows += `<tr class=\"detail-row\"><td colspan=\"2\" style=\"padding-left:1em;font-size:0.9em;\">${esc(v.regel)}</td></tr>`;\n  if (v.voraussetzung && v.voraussetzung !== '-') rows += `<tr class=\"detail-row\"><td colspan=\"2\" style=\"padding-left:1em;font-size:0.85em;font-style:italic;\"><strong>Voraussetzung:</strong> ${esc(v.voraussetzung)}</td></tr>`;\n  return rows;\n}).join('');\nreturn `<table class=\"vorteile-table\" style=\"width:100%;\"><thead><tr><th style=\"text-align:left;\">Vorteil</th><th style=\"width:100px;\">AP</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": true
            }
          ],
          "heading": "Vorteile",
          "hasRule": false
        },
        {
          "type": "group",
          "id": "nachteile-section",
          "properties": [
            "nachteile"
          ],
          "conditioned": true,
          "nested": [
            {
              "type": "collapse",
              "id": "nachteile-collapse",
              "heading": "",
              "hasRule": false,
              "conditioned": false,
              "nested": [
                {
                  "type": "property",
                  "id": "nachteile-table",
                  "display": "",
                  "properties": [
                    "nachteile"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const items = monster.nachteile ?? [];\nif (!Array.isArray(items) || items.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst renderRows = () => items.map(n => {\n  let rows = `<tr><td><strong>${esc(n.name)}</strong></td><td>${esc(n.ap)}</td></tr>`;\n  if (n.regel) rows += `<tr class=\"detail-row\"><td colspan=\"2\" style=\"padding-left:1em;font-size:0.9em;\">${esc(n.regel)}</td></tr>`;\n  if (n.voraussetzung && n.voraussetzung !== '-') rows += `<tr class=\"detail-row\"><td colspan=\"2\" style=\"padding-left:1em;font-size:0.85em;font-style:italic;\"><strong>Voraussetzung:</strong> ${esc(n.voraussetzung)}</td></tr>`;\n  return rows;\n}).join('');\nreturn `<table class=\"nachteile-table\" style=\"width:100%;\"><thead><tr><th style=\"text-align:left;\">Nachteil</th><th style=\"width:100px;\">AP</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": true
            }
          ],
          "heading": "Nachteile",
          "hasRule": false
        },
        {
          "type": "group",
          "id": "sonderfertigkeiten-section",
          "properties": [
            "sonderfertigkeiten"
          ],
          "conditioned": true,
          "nested": [
            {
              "type": "collapse",
              "id": "sonderfertigkeiten-collapse",
              "heading": "",
              "hasRule": false,
              "conditioned": false,
              "nested": [
                {
                  "type": "property",
                  "id": "sonderfertigkeiten-table",
                  "display": "",
                  "properties": [
                    "sonderfertigkeiten"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const items = monster.sonderfertigkeiten ?? [];\nif (!Array.isArray(items) || items.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst renderRows = () => items.map(sf => {\n  let rows = `<tr><td><strong>${esc(sf.name)}</strong></td><td>${esc(sf.kategorie ?? '-')}</td><td>${esc(sf.ap)}</td></tr>`;\n  if (sf.regel) rows += `<tr class=\"detail-row\"><td colspan=\"3\" style=\"padding-left:1em;font-size:0.9em;\">${esc(sf.regel)}</td></tr>`;\n  if (sf.voraussetzung && sf.voraussetzung !== '-') rows += `<tr class=\"detail-row\"><td colspan=\"3\" style=\"padding-left:1em;font-size:0.85em;font-style:italic;\"><strong>Voraussetzung:</strong> ${esc(sf.voraussetzung)}</td></tr>`;\n  return rows;\n}).join('');\nreturn `<table class=\"sonderfertigkeiten-table\" style=\"width:100%;\"><thead><tr><th style=\"text-align:left;\">Sonderfertigkeit</th><th>Kategorie</th><th style=\"width:100px;\">AP</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": true
            }
          ],
          "heading": "Sonderfertigkeiten",
          "hasRule": false
        }
      ],
      "name": "DSA_Lite",
      "id": "ea6b2af9aa08",
      "diceParsing": [],
      "columnWidth": 900,
      "columns": 1,
      "cssProperties": {
        "primary-color": "#bd93f9",
        "rule-color": "#6272a4",
        "background-color": "#282a36",
        "bar-color": "#44475a",
        "bar-border-size": "1px",
        "bar-border-color": "#6272a4",
        "border-size": "1px",
        "border-color": "#44475a",
        "box-shadow-color": "rgba(0,0,0,0.3)",
        "box-shadow-x-offset": "0",
        "box-shadow-y-offset": "0",
        "box-shadow-blur": "8px",
        "font-color": "#f8f8f2",
        "font-weight": "400",
        "heading-font-color": "#ff79c6",
        "heading-font-size": "1.5em",
        "heading-font-weight": "700",
        "property-name-font-color": "#8be9fd",
        "property-name-font-weight": "bold",
        "section-heading-font-color": "#50fa7b",
        "section-heading-font-size": "1.2em",
        "section-heading-font-weight": "700",
        "section-heading-border-color": "#6272a4",
        "section-heading-border-size": "1px",
        "table-header-font-weight": "bold",
        "content-font": "inherit",
        "heading-font": "inherit",
        "image-border-size": "2px",
        "image-border-color": "#bd93f9",
        "imageWidth": "350px",
        "imageHeight": "540px"
      },
      "forceColumns": true
    },
    {
      "blocks": [
        {
          "type": "inline",
          "id": "0bdbf8e98b69",
          "properties": [],
          "hasRule": false,
          "nested": [
            {
              "type": "group",
              "id": "dac95b5a795b",
              "properties": [
                "name"
              ],
              "nested": [
                {
                  "type": "inline",
                  "id": "bab8f97afb6a",
                  "properties": [],
                  "hasRule": false,
                  "nested": [
                    {
                      "type": "heading",
                      "id": "78eb3acaa999",
                      "properties": [
                        "name"
                      ],
                      "conditioned": true,
                      "size": 1
                    },
                    {
                      "type": "inline",
                      "id": "b93b4a3a5b18",
                      "properties": [],
                      "hasRule": false,
                      "nested": [
                        {
                          "type": "action",
                          "id": "598a9b596a18",
                          "icon": "sword",
                          "callback": "try { InitiativeTracker.newEncounter({roll: true, creatures: [monster]}); } catch(e) {}"
                        },
                        {
                          "type": "action",
                          "id": "fabb9b089939",
                          "icon": "plus-with-circle",
                          "callback": "try { InitiativeTracker.addCreatures([monster]); } catch(e) {}"
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "property",
                  "id": "info-table",
                  "display": "",
                  "properties": [
                    "alter",
                    "geschlecht",
                    "haarfarbe",
                    "augenfarbe",
                    "groesse",
                    "gewicht",
                    "spezies",
                    "kultur",
                    "geburtsort",
                    "profession",
                    "sozialstatus"
                  ],
                  "conditioned": false,
                  "callback": "const get = k => monster[k] ?? monster.info?.[k] ?? '-';\nconst allowed = ['Mensch', 'Elf', 'Halbelf', 'Zwerg'];\nconst raw = monster.info?.spezies ?? monster.info?.species ?? monster.spezies;\nconst species = typeof raw === 'string' ? raw.trim() : '';\nconst spVal = allowed.includes(species) ? species : 'Mensch/Elf/Halbelf/Zwerg';\nconst rows = [\n    ['Alter:', get('alter'), 'Geschlecht:', get('geschlecht') || 'm/w/d'],\n    ['Haarfarbe:', get('haarfarbe'), 'Augenfarbe:', get('augenfarbe')],\n    ['Gr√∂√üe:', get('groesse'), 'Gewicht:', get('gewicht')],\n    ['Spezies:', spVal, 'Kultur:', get('kultur')],\n    ['Geburtsort:', get('geburtsort'), 'Profession:', get('profession')],\n    ['Sozialstatus:', get('sozialstatus') || 'Unfrei/Frei/Niederadel/Adel/Hochadel', '', '']\n];\nreturn `<table class=\"info-grid\" style=\"width:100%;border-collapse:collapse;\"><tbody>${rows.map(r => `<tr><td style=\"text-align:right;font-weight:bold;padding:2px 8px;width:25%;\">${r[0]}</td><td style=\"text-align:left;padding:2px 8px;width:25%;\">${r[1]}</td><td style=\"text-align:right;font-weight:bold;padding:2px 8px;width:25%;\">${r[2]}</td><td style=\"text-align:left;padding:2px 8px;width:25%;\">${r[3]}</td></tr>`).join('')}</tbody></table>`;"
                },
                {
                  "type": "group",
                  "id": "3ad858d9293b",
                  "properties": [],
                  "nested": [
                    {
                      "type": "property",
                      "id": "calc-values-table",
                      "display": "",
                      "properties": [
                        "le",
                        "le_mod",
                        "ae",
                        "ae_mod",
                        "ae_max",
                        "ke",
                        "ke_mod",
                        "ke_max",
                        "schip",
                        "schip_max",
                        "spezies",
                        "sk_mod",
                        "zk_mod",
                        "aw_mod",
                        "ini_mod",
                        "ws_mod",
                        "gs_mod"
                      ],
                      "conditioned": false,
                      "callback": "const bases = {'Mensch': { le: 5, sk: -5, zk: -5, gs: 8 }, 'Elf': { le: 2, sk: -4, zk: -6, gs: 8 }, 'Halbelf': { le: 5, sk: -4, zk: -6, gs: 8 }, 'Zwerg': { le: 8, sk: -4, zk: -4, gs: 6 }};\nconst toNum = v => { if (typeof v === 'number') return v; if (typeof v === 'string' && v.trim() !== '') { const p = Number(v); return Number.isFinite(p) ? p : 0; } return 0; };\nconst rawSpecies = monster.info?.spezies ?? monster.info?.species ?? monster.spezies ?? monster.species;\nconst species = typeof rawSpecies === 'string' ? rawSpecies.trim() : '';\nconst b = bases[species] ?? {};\nconst attrs = monster.eigenschaften ?? {};\nconst attr = k => toNum(attrs[k] ?? monster[k] ?? monster[`eigenschaften.${k}`]);\nconst get = k => monster[k] ?? '-';\nconst ko = attr('ko'); const mu = attr('mu'); const ge = attr('ge'); const kl = attr('kl'); const iin = attr('in'); const kk = attr('kk');\nconst modLE = toNum(monster.le_mod ?? 0);\nconst maxLE = b.le !== undefined ? b.le + (2 * ko) + modLE : '-';\nconst skMod = toNum(monster.sk_mod ?? 0); const zkMod = toNum(monster.zk_mod ?? 0); const awMod = toNum(monster.aw_mod ?? 0); const iniMod = toNum(monster.ini_mod ?? 0); const wsMod = toNum(monster.ws_mod ?? 0);\nconst awBase = Number.isFinite(ge) ? Math.round(ge / 2) : 0; const aw = awBase + awMod;\nconst iniBase = (Number.isFinite(mu) && Number.isFinite(ge)) ? Math.round((mu + ge) / 2) : 0; const ini = iniBase + iniMod;\nconst skBase = b.sk !== undefined ? Math.round((mu + kl + iin) / 6) + b.sk : 0; const sk = skBase + skMod;\nconst zkBase = b.zk !== undefined ? Math.round((ko + ko + kk) / 6) + b.zk : 0; const zk = zkBase + zkMod;\nconst wsBase = Number.isFinite(ko) ? Math.round(ko / 2) : 0; const ws = wsBase + wsMod;\nconst gsBase = b.gs ?? 0; const gsMod = toNum(monster.gs_mod ?? 0); const gs = gsBase + gsMod;\nconst aeMax = toNum(monster.ae_max ?? 0);\nconst keMax = toNum(monster.ke_max ?? 0);\nconst fmtMod = (base, mod, total) => mod !== 0 ? `${total} (${base}${mod >= 0 ? '+' : ''}${mod})` : `${total}`;\nconst rows = [\n    ['LE:', get('le'), 'Mod. LE:', get('le_mod'), 'Max LE:', maxLE]\n];\nif (aeMax > 0) rows.push(['AE:', get('ae'), 'Mod. AE:', get('ae_mod'), 'Max AE:', get('ae_max')]);\nif (keMax > 0) rows.push(['KE:', get('ke'), 'Mod. KE:', get('ke_mod'), 'Max KE:', get('ke_max')]);\nrows.push(['SK:', fmtMod(skBase, skMod, sk), 'ZK:', fmtMod(zkBase, zkMod, zk), 'GS:', gsBase > 0 ? fmtMod(gsBase, gsMod, gs) : '-']);\nrows.push(['AW:', fmtMod(awBase, awMod, aw), 'Ini:', fmtMod(iniBase, iniMod, ini), 'WS:', fmtMod(wsBase, wsMod, ws)]);\nrows.push(['SchiP:', get('schip'), 'Max SchiP:', get('schip_max'), '', '']);\nconst cell = (txt, bold) => `<td style=\"text-align:${bold ? 'right' : 'left'};${bold ? 'font-weight:bold;' : ''}padding:2px 8px;\">${txt}</td>`;\nreturn `<table class=\"grundwerte-grid\" style=\"width:100%;border-collapse:collapse;\"><tbody>${rows.map(r => `<tr>${cell(r[0],true)}${cell(r[1],false)}${cell(r[2],true)}${cell(r[3],false)}${cell(r[4],true)}${cell(r[5],false)}</tr>`).join('')}</tbody></table>`;"
                    }
                  ],
                  "heading": "Grundwerte",
                  "hasRule": false,
                  "cls": "baseValues"
                }
              ],
              "conditioned": true,
              "cls": "baseInfo"
            },
            {
              "type": "image",
              "id": "7b3b093a59f9",
              "properties": [
                "image"
              ],
              "fallback": ""
            }
          ]
        },
        {
          "type": "inline",
          "id": "6809082b5b4a",
          "heading": "Eigenschaften",
          "properties": [
            "eigenschaften"
          ],
          "hasRule": false,
          "conditioned": true,
          "nested": [
            {
              "type": "property",
              "id": "eigenschaften-table",
              "display": "",
              "properties": [
                "mu",
                "kl",
                "in",
                "ch",
                "ff",
                "ge",
                "ko",
                "kk",
                "ap_gesamt"
              ],
              "conditioned": false,
              "callback": "const attrs = monster.eigenschaften ?? {};\nconst get = k => attrs[k] ?? monster[k] ?? monster[`eigenschaften.${k}`] ?? '-';\nconst headers = ['MU', 'KL', 'IN', 'CH', 'FF', 'GE', 'KO', 'KK'];\nconst keys = ['mu', 'kl', 'in', 'ch', 'ff', 'ge', 'ko', 'kk'];\nconst values = keys.map(k => get(k));\nconst ap = monster.ap_gesamt ?? 0;\nconst apBox = `<div style=\"display:inline-flex;flex-direction:column;align-items:center;justify-content:center;padding:8px 16px;background:var(--bar-color);border-radius:4px;border:1px solid var(--border-color);margin-left:12px;\"><span style=\"font-size:0.8em;color:var(--property-name-font-color);\">AP</span><span style=\"font-size:1.3em;font-weight:bold;\">${ap}</span></div>`;\nreturn `<div style=\"display:flex;align-items:center;\"><table class=\"eigenschaften-table\" style=\"flex:1;border-collapse:collapse;text-align:center;\"><thead><tr>${headers.map(h => `<th style=\"padding:6px 10px;\">${h}</th>`).join('')}</tr></thead><tbody><tr>${values.map(v => `<td style=\"padding:6px 10px;\">${v}</td>`).join('')}</tr></tbody></table>${apBox}</div>`;"
            }
          ]
        },
        {
          "type": "inline",
          "id": "talent-dice-section",
          "heading": "W√ºrfel",
          "properties": [
            "3d20",
            "1d20"
          ],
          "conditioned": true,
          "nested": [
            {
              "type": "property",
              "id": "talent-dice",
              "display": "üé≤ Fertigkeitenprobe w√ºrfeln",
              "properties": [
                "3d20"
              ],
              "fallback": "",
              "conditioned": true,
              "markdown": true
            }
          ]
        },
        {
          "type": "group",
          "id": "cbf94b49e91a",
          "properties": [],
          "nested": [
            {
              "type": "collapse",
              "id": "5b2bbbdb7b4b",
              "heading": "",
              "hasRule": false,
              "conditioned": false,
              "nested": [
                {
                  "type": "group",
                  "id": "7b491afa2aca",
                  "properties": [],
                  "nested": [
                    {
                      "type": "collapse",
                      "id": "ca783a6b2959",
                      "heading": "Nahkampfwaffen",
                      "hasRule": false,
                      "conditioned": true,
                      "properties": [
                        "nahkampfwaffen"
                      ],
                      "nested": [
                        {
                          "type": "group",
                          "id": "6bfb08aa8aeb",
                          "properties": [],
                          "nested": [
                            {
                              "type": "property",
                              "id": "nahkampfwaffen-table",
                              "display": "",
                              "properties": [
                                "nahkampfwaffen"
                              ],
                              "fallback": "",
                              "conditioned": true,
                              "callback": "const weapons = monster.nahkampfwaffen ?? [];\nif (!Array.isArray(weapons) || weapons.length === 0) return \"\";\nconst escapeHtml = str => String(str ?? \"\").replace(/[&<>\"']/g, c => ({ \"&\": \"&amp;\", \"<\": \"&lt;\", \">\": \"&gt;\", '\"': \"&quot;\", \"'\": \"&#39;\" }[c] || c));\nconst toNum = v => { if (typeof v === \"number\") return v; if (typeof v === \"string\") { const p = Number(v.trim()); return Number.isFinite(p) ? p : 0; } return 0; };\nconst toUmlaut = s => s.replace(/oe/g, '√∂').replace(/ae/g, '√§').replace(/ue/g, '√º');\nconst toAscii = s => s.replace(/√∂/g, 'oe').replace(/√§/g, 'ae').replace(/√º/g, 'ue');\nconst attrNames = { mu: \"MU\", kl: \"KL\", in: \"IN\", ch: \"CH\", ff: \"FF\", ge: \"GE\", ko: \"KO\", kk: \"KK\" };\nconst techMap = {\n    \"dolche\": { attrKeys: [\"ge\"], parry: true },\n    \"f√§cher\": { attrKeys: [\"ge\"], parry: true },\n    \"fechtwaffen\": { attrKeys: [\"ge\"], parry: true },\n    \"hiebwaffen\": { attrKeys: [\"kk\"], parry: true },\n    \"kettenwaffen\": { attrKeys: [\"kk\"], parry: false },\n    \"lanzen\": { attrKeys: [\"kk\"], parry: true },\n    \"peitschen\": { attrKeys: [\"ge\"], parry: false },\n    \"raufen\": { attrKeys: [\"ge\", \"kk\"], parry: true },\n    \"schilde\": { attrKeys: [\"kk\"], parry: true },\n    \"schwerter\": { attrKeys: [\"ge\", \"kk\"], parry: true },\n    \"stangenwaffen\": { attrKeys: [\"ge\", \"kk\"], parry: true },\n    \"zweihandhiebwaffen\": { attrKeys: [\"kk\"], parry: true },\n    \"zweihandschwerter\": { attrKeys: [\"kk\"], parry: true }\n};\nconst attrs = monster.eigenschaften ?? {};\nconst getAttr = k => toNum(attrs[k] ?? monster[k] ?? monster[`eigenschaften.${k}`]);\nconst bonusFromAttr = k => { const v = getAttr(k); return v <= 8 ? 0 : Math.round((v - 8) / 3); };\nconst getKtw = key => {\n    const store = monster.kampftechniken ?? {};\n    const k = key.toLowerCase().replace(/[^a-z√§√∂√º√ü]/g, \"\");\n    if (k in store) return toNum(store[k]);\n    for (const storeKey in store) { if (toUmlaut(storeKey) === k) return toNum(store[storeKey]); }\n    const kAscii = toAscii(k);\n    if (kAscii in store) return toNum(store[kAscii]);\n    for (const storeKey in store) { if (storeKey.toLowerCase() === k || storeKey.toLowerCase() === kAscii) return toNum(store[storeKey]); }\n    if (`kampftechniken.${k}` in monster) return toNum(monster[`kampftechniken.${k}`]);\n    return 6;\n};\nconst getMaxLAttr = lField => {\n    if (!lField) return 0;\n    const lStr = String(lField).toLowerCase();\n    const parts = lStr.split('/').map(p => p.trim());\n    let maxVal = 0;\n    for (const part of parts) {\n        const val = getAttr(part);\n        if (val > maxVal) maxVal = val;\n    }\n    return maxVal;\n};\nconst cols = 12;\nconst renderRows = () => weapons.map(w => {\n    const waffe = escapeHtml(w.waffe ?? w.name ?? \"-\");\n    const techRaw = String(w.kampftechnik ?? w.technik ?? \"\").toLowerCase().replace(/[^a-z√§√∂√º]/g, \"\");\n    const kampftechnik = escapeHtml(w.kampftechnik ?? w.technik ?? \"-\");\n    const lDisplay = escapeHtml(w.l ?? \"-\");\n    const sVal = toNum(w.s ?? 0);\n    const lAttrVal = getMaxLAttr(w.l);\n    const tpBonus = lAttrVal > sVal ? lAttrVal - sVal : 0;\n    const tpBase = escapeHtml(w.tp ?? \"-\");\n    const tpDisplay = tpBonus > 0 ? `${tpBase} (+${tpBonus})` : tpBase;\n    const atMod = toNum(w.at_mod ?? 0);\n    const paMod = toNum(w.pa_mod ?? 0);\n    const atModStr = atMod === 0 ? \"0\" : (atMod > 0 ? \"+\" + atMod : String(atMod));\n    const paModStr = paMod === 0 ? \"0\" : (paMod > 0 ? \"+\" + paMod : String(paMod));\n    const rw = escapeHtml(w.rw ?? \"-\");\n    const laenge = escapeHtml(w.laenge ?? w.l√§nge ?? \"-\");\n    const gewicht = escapeHtml(w.gewicht ?? \"-\");\n    const tech = techMap[techRaw];\n    const ktw = getKtw(techRaw);\n    const baseAt = ktw + bonusFromAttr(\"mu\") + atMod;\n    let basePa = \"-\";\n    if (tech && tech.parry) {\n        const attrBonus = tech.attrKeys.reduce((max, k) => Math.max(max, bonusFromAttr(k)), 0);\n        basePa = String(Math.ceil(ktw / 2) + attrBonus + paMod);\n    }\n    let rows = `<tr class=\"weapon-main\"><td>${waffe}</td><td>${kampftechnik}</td><td>${lDisplay}</td><td>${sVal}</td><td>${tpDisplay}</td><td>${atModStr}</td><td>${paModStr}</td><td>${rw}</td><td>${laenge}</td><td>${baseAt}</td><td>${basePa}</td><td>${gewicht}</td></tr>`;\n    if (w.waffenvorteil) rows += `<tr class=\"weapon-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Vorteil:</strong> ${escapeHtml(w.waffenvorteil)}</td></tr>`;\n    if (w.waffennachteil) rows += `<tr class=\"weapon-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Nachteil:</strong> ${escapeHtml(w.waffennachteil)}</td></tr>`;\n    return rows;\n}).join(\"\");\nreturn `<table class=\"nahkampfwaffen-table\"><thead><tr><th>Waffe</th><th>Kampftechnik</th><th>L</th><th>S</th><th>TP</th><th>AT Mod.</th><th>PA Mod.</th><th>RW</th><th>L√§nge</th><th>AT</th><th>PA</th><th>Gewicht</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                            }
                          ]
                        }
                      ],
                      "open": true
                    },
                    {
                      "type": "collapse",
                      "id": "2a1bd808ab4a",
                      "heading": "Fernkampfwaffen",
                      "hasRule": false,
                      "conditioned": true,
                      "properties": [
                        "fernkampfwaffen"
                      ],
                      "nested": [
                        {
                          "type": "group",
                          "id": "197bdbda7bfa",
                          "properties": [],
                          "nested": [
                            {
                              "type": "property",
                              "id": "fernkampfwaffen-table",
                              "display": "",
                              "properties": [
                                "fernkampfwaffen"
                              ],
                              "fallback": "",
                              "conditioned": true,
                              "callback": "const weapons = monster.fernkampfwaffen ?? [];\nif (!Array.isArray(weapons) || weapons.length === 0) return \"\";\nconst escapeHtml = str => String(str ?? \"\").replace(/[&<>\"']/g, c => ({ \"&\": \"&amp;\", \"<\": \"&lt;\", \">\": \"&gt;\", '\"': \"&quot;\", \"'\": \"&#39;\" }[c] || c));\nconst toNum = v => { if (typeof v === \"number\") return v; if (typeof v === \"string\") { const p = Number(v.trim()); return Number.isFinite(p) ? p : 0; } return 0; };\nconst toUmlaut = s => s.replace(/oe/g, '√∂').replace(/ae/g, '√§').replace(/ue/g, '√º');\nconst toAscii = s => s.replace(/√∂/g, 'oe').replace(/√§/g, 'ae').replace(/√º/g, 'ue');\nconst attrs = monster.eigenschaften ?? {};\nconst getAttr = k => toNum(attrs[k] ?? monster[k] ?? monster[`eigenschaften.${k}`]);\nconst bonusFromAttr = k => { const v = getAttr(k); return v <= 8 ? 0 : Math.round((v - 8) / 3); };\nconst getKtw = key => {\n    const store = monster.kampftechniken ?? {};\n    const k = key.toLowerCase().replace(/[^a-z√§√∂√º√ü]/g, \"\");\n    if (k in store) return toNum(store[k]);\n    for (const storeKey in store) { if (toUmlaut(storeKey) === k) return toNum(store[storeKey]); }\n    const kAscii = toAscii(k);\n    if (kAscii in store) return toNum(store[kAscii]);\n    for (const storeKey in store) { if (storeKey.toLowerCase() === k || storeKey.toLowerCase() === kAscii) return toNum(store[storeKey]); }\n    if (`kampftechniken.${k}` in monster) return toNum(monster[`kampftechniken.${k}`]);\n    return 6;\n};\nconst cols = 8;\nconst renderRows = () => weapons.map(w => {\n    const waffe = escapeHtml(w.waffe ?? w.name ?? \"-\");\n    const techRaw = String(w.kampftechnik ?? w.technik ?? \"\").toLowerCase().replace(/[^a-z√§√∂√º]/g, \"\");\n    const kampftechnik = escapeHtml(w.kampftechnik ?? w.technik ?? \"-\");\n    const lz = escapeHtml(w.lz ?? \"-\");\n    const tp = escapeHtml(w.tp ?? \"-\");\n    const rw = escapeHtml(w.rw ?? \"-\");\n    const laenge = escapeHtml(w.laenge ?? w.l√§nge ?? \"-\");\n    const gewicht = escapeHtml(w.gewicht ?? \"-\");\n    const ktw = getKtw(techRaw);\n    const fk = ktw + bonusFromAttr(\"ff\");\n    let rows = `<tr class=\"weapon-main\"><td>${waffe}</td><td>${kampftechnik}</td><td>${lz}</td><td>${tp}</td><td>${rw}</td><td>${fk}</td><td>${gewicht}</td><td>${laenge}</td></tr>`;\n    if (w.waffenvorteil) rows += `<tr class=\"weapon-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Vorteil:</strong> ${escapeHtml(w.waffenvorteil)}</td></tr>`;\n    if (w.waffennachteil) rows += `<tr class=\"weapon-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Nachteil:</strong> ${escapeHtml(w.waffennachteil)}</td></tr>`;\n    return rows;\n}).join(\"\");\nreturn `<table class=\"fernkampfwaffen-table\"><thead><tr><th>Waffe</th><th>Kampftechnik</th><th>LZ</th><th>TP</th><th>RW</th><th>FK</th><th>Gewicht</th><th>L√§nge</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                            }
                          ]
                        }
                      ],
                      "open": false
                    },
                    {
                      "type": "collapse",
                      "id": "f9bae909c9e8",
                      "heading": "R√ºstungen",
                      "hasRule": false,
                      "conditioned": true,
                      "properties": [
                        "ruestungen"
                      ],
                      "nested": [
                        {
                          "type": "group",
                          "id": "6a983b3a2bcb",
                          "properties": [],
                          "nested": [
                            {
                              "type": "property",
                              "id": "ruestungen-table",
                              "display": "",
                              "properties": [
                                "ruestungen"
                              ],
                              "fallback": "",
                              "conditioned": true,
                              "callback": "const armor = monster.ruestungen ?? monster.r√ºstungen ?? [];\nif (!Array.isArray(armor) || armor.length === 0) return \"\";\nconst escapeHtml = str => String(str ?? \"\").replace(/[&<>\"']/g, c => ({ \"&\": \"&amp;\", \"<\": \"&lt;\", \">\": \"&gt;\", '\"': \"&quot;\", \"'\": \"&#39;\" }[c] || c));\nconst parseAbzuege = str => { const result = { gs: '-', ini: '-' }; if (!str || str === '-') return result; const gsMatch = String(str).match(/(-?\\d+)\\s*GS/i); const iniMatch = String(str).match(/(-?\\d+)\\s*INI/i); if (gsMatch) result.gs = gsMatch[1]; if (iniMatch) result.ini = iniMatch[1]; return result; };\nconst cols = 6;\nconst renderRows = () => armor.map(a => {\n    const ruestung = escapeHtml(a.ruestung ?? a.r√ºstung ?? a.name ?? \"-\");\n    const rs = escapeHtml(a.rs ?? \"-\");\n    const be = escapeHtml(a.be ?? \"-\");\n    const abzuege = parseAbzuege(a.zusaetzliche_abzuege);\n    const gs = escapeHtml(a.gs ?? abzuege.gs);\n    const ini = escapeHtml(a.ini ?? abzuege.ini);\n    const gewicht = escapeHtml(a.gewicht ?? \"-\");\n    let rows = `<tr class=\"armor-main\"><td>${ruestung}</td><td>${rs}</td><td>${be}</td><td>${gs}</td><td>${ini}</td><td>${gewicht}</td></tr>`;\n    if (a.anmerkung) rows += `<tr class=\"armor-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Anmerkung:</strong> ${escapeHtml(a.anmerkung)}</td></tr>`;\n    if (a.ruestungsvorteil) rows += `<tr class=\"armor-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Vorteil:</strong> ${escapeHtml(a.ruestungsvorteil)}</td></tr>`;\n    if (a.ruestungsnachteil) rows += `<tr class=\"armor-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Nachteil:</strong> ${escapeHtml(a.ruestungsnachteil)}</td></tr>`;\n    return rows;\n}).join(\"\");\nreturn `<table class=\"ruestungen-table\"><thead><tr><th>R√ºstung</th><th>RS</th><th>BE</th><th>GS</th><th>INI</th><th>Gewicht</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                            }
                          ]
                        }
                      ],
                      "open": false
                    }
                  ]
                }
              ],
              "open": true
            }
          ],
          "heading": "Ausr√ºstung"
        },
        {
          "type": "group",
          "id": "aaea6b8ba8c8",
          "properties": [],
          "nested": [
            {
              "type": "collapse",
              "id": "08dbfbf93939",
              "heading": "",
              "hasRule": false,
              "conditioned": false,
              "nested": [
                {
                  "type": "group",
                  "id": "181a6b89dbb9",
                  "properties": [],
                  "nested": [
                    {
                      "type": "collapse",
                      "id": "e83b995a0aeb",
                      "heading": "K√∂rpertalente",
                      "hasRule": false,
                      "conditioned": false,
                      "nested": [
                        {
                          "type": "group",
                          "id": "6b98682b58a8",
                          "properties": [],
                          "nested": [
                            {
                              "type": "property",
                              "id": "talent-koerper-table",
                              "display": "",
                              "properties": [
                                "talente"
                              ],
                              "fallback": "",
                              "conditioned": false,
                              "callback": "const talents = [\n    { key: \"fliegen\", name: \"Fliegen\", attrs: [\"mu\", \"in\", \"ge\"], be: \"Ja\", sf: \"B\" },\n    { key: \"gaukeleien\", name: \"Gaukeleien\", attrs: [\"mu\", \"ch\", \"ff\"], be: \"Ja\", sf: \"A\" },\n    { key: \"klettern\", name: \"Klettern\", attrs: [\"mu\", \"ge\", \"kk\"], be: \"Ja\", sf: \"B\" },\n    { key: \"koerperbeherrschung\", name: \"K√∂rperbeherrschung\", attrs: [\"ge\", \"ge\", \"ko\"], be: \"Ja\", sf: \"D\" },\n    { key: \"kraftakt\", name: \"Kraftakt\", attrs: [\"ko\", \"kk\", \"kk\"], be: \"Ja\", sf: \"B\" },\n    { key: \"reiten\", name: \"Reiten\", attrs: [\"ch\", \"ge\", \"kk\"], be: \"Ja\", sf: \"B\" },\n    { key: \"schwimmen\", name: \"Schwimmen\", attrs: [\"ge\", \"ko\", \"kk\"], be: \"Ja\", sf: \"B\" },\n    { key: \"selbstbeherrschung\", name: \"Selbstbeherrschung\", attrs: [\"mu\", \"mu\", \"ko\"], be: \"Nein\", sf: \"D\" },\n    { key: \"singen\", name: \"Singen\", attrs: [\"kl\", \"ch\", \"ko\"], be: \"Evtl\", sf: \"A\" },\n    { key: \"sinnesschaerfe\", name: \"Sinnessch√§rfe\", attrs: [\"kl\", \"in\", \"in\"], be: \"Evtl\", sf: \"D\" },\n    { key: \"tanzen\", name: \"Tanzen\", attrs: [\"kl\", \"ch\", \"ge\"], be: \"Ja\", sf: \"A\" },\n    { key: \"taschendiebstahl\", name: \"Taschendiebstahl\", attrs: [\"mu\", \"ff\", \"ge\"], be: \"Ja\", sf: \"B\" },\n    { key: \"verbergen\", name: \"Verbergen\", attrs: [\"mu\", \"in\", \"ge\"], be: \"Ja\", sf: \"C\" },\n    { key: \"zechen\", name: \"Zechen\", attrs: [\"kl\", \"ko\", \"kk\"], be: \"Nein\", sf: \"A\" }\n];\nconst attrNames = { mu: \"MU\", kl: \"KL\", in: \"IN\", ch: \"CH\", ff: \"FF\", ge: \"GE\", ko: \"KO\", kk: \"KK\" };\nconst toValue = v => { if (v == null) return 0; if (typeof v === \"number\") return v; if (typeof v === \"string\") { const p = Number(v.trim()); return Number.isNaN(p) ? 0 : p; } if (typeof v === \"object\" && \"fw\" in v) return toValue(v.fw); return 0; };\nconst getAttr = k => { const a = monster.eigenschaften ?? {}; return toValue(a[k] ?? monster[k] ?? monster[`eigenschaften.${k}`]); };\nconst getFW = k => { const s = monster.talente ?? {}; if (k in s) return toValue(s[k]); if (`talente.${k}` in monster) return toValue(monster[`talente.${k}`]); return 0; };\nconst getMod = k => { const m = monster.talente_mod ?? {}; if (k in m) return toValue(m[k]); if (`talente_mod.${k}` in monster) return toValue(monster[`talente_mod.${k}`]); return 0; };\nconst probeStr = a => a.map(x => attrNames[x] || x.toUpperCase()).join(\"/\");\nconst renderRows = () => talents.map(t => { const fw = getFW(t.key); const mod = getMod(t.key); const modStr = mod === 0 ? \"0\" : (mod > 0 ? \"+\" + mod : String(mod)); const pd = probeStr(t.attrs); const av = t.attrs.map(a => getAttr(a) + mod); const al = t.attrs.map(a => attrNames[a] || a.toUpperCase()); const ts = av.map((v, i) => `${al[i]}:${v}`).join(\" / \"); return `<tr><td>${t.name}</td><td class=\"talent-probe\"><strong>${pd}</strong><br/><small>${ts}</small></td><td>${modStr}</td><td>${t.be}</td><td>${t.sf}</td><td>${fw}</td></tr>`; }).join(\"\");\nreturn `<table class=\"talent-table\"><thead><tr><th>Talent</th><th>Probe (Zielwerte)</th><th>Mod.</th><th>BE</th><th>Sf.</th><th>Fw</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                            }
                          ]
                        }
                      ],
                      "open": false
                    },
                    {
                      "type": "collapse",
                      "id": "bbab683a297a",
                      "heading": "Gesellschaftstalente",
                      "hasRule": false,
                      "conditioned": false,
                      "nested": [
                        {
                          "type": "group",
                          "id": "f9eb68cb0818",
                          "properties": [],
                          "nested": [
                            {
                              "type": "property",
                              "id": "talent-gesellschaft-table",
                              "display": "",
                              "properties": [
                                "talente"
                              ],
                              "fallback": "",
                              "conditioned": false,
                              "callback": "const talents = [\n    { key: \"bekehren_ueberzeugen\", name: \"Bekehren & √úberzeugen\", attrs: [\"mu\", \"kl\", \"ch\"], be: \"Nein\", sf: \"B\" },\n    { key: \"betoeren\", name: \"Bet√∂ren\", attrs: [\"mu\", \"ch\", \"ch\"], be: \"Evtl\", sf: \"B\" },\n    { key: \"einschuechtern\", name: \"Einsch√ºchtern\", attrs: [\"mu\", \"in\", \"ch\"], be: \"Nein\", sf: \"B\" },\n    { key: \"etikette\", name: \"Etikette\", attrs: [\"kl\", \"in\", \"ch\"], be: \"Nein\", sf: \"B\" },\n    { key: \"gassenwissen\", name: \"Gassenwissen\", attrs: [\"kl\", \"in\", \"ch\"], be: \"Evtl\", sf: \"C\" },\n    { key: \"menschenkenntnis\", name: \"Menschenkenntnis\", attrs: [\"kl\", \"in\", \"ch\"], be: \"Nein\", sf: \"C\" },\n    { key: \"ueberreden\", name: \"√úberreden\", attrs: [\"mu\", \"in\", \"ch\"], be: \"Nein\", sf: \"C\" },\n    { key: \"verkleiden\", name: \"Verkleiden\", attrs: [\"in\", \"ch\", \"ge\"], be: \"Ja\", sf: \"B\" },\n    { key: \"willenskraft\", name: \"Willenskraft\", attrs: [\"mu\", \"in\", \"ch\"], be: \"Nein\", sf: \"D\" }\n];\nconst attrNames = { mu: \"MU\", kl: \"KL\", in: \"IN\", ch: \"CH\", ff: \"FF\", ge: \"GE\", ko: \"KO\", kk: \"KK\" };\nconst toValue = v => { if (v == null) return 0; if (typeof v === \"number\") return v; if (typeof v === \"string\") { const p = Number(v.trim()); return Number.isNaN(p) ? 0 : p; } if (typeof v === \"object\" && \"fw\" in v) return toValue(v.fw); return 0; };\nconst getAttr = k => { const a = monster.eigenschaften ?? {}; return toValue(a[k] ?? monster[k] ?? monster[`eigenschaften.${k}`]); };\nconst getFW = k => { const s = monster.talente ?? {}; if (k in s) return toValue(s[k]); if (`talente.${k}` in monster) return toValue(monster[`talente.${k}`]); return 0; };\nconst getMod = k => { const m = monster.talente_mod ?? {}; if (k in m) return toValue(m[k]); if (`talente_mod.${k}` in monster) return toValue(monster[`talente_mod.${k}`]); return 0; };\nconst probeStr = a => a.map(x => attrNames[x] || x.toUpperCase()).join(\"/\");\nconst renderRows = () => talents.map(t => { const fw = getFW(t.key); const mod = getMod(t.key); const modStr = mod === 0 ? \"0\" : (mod > 0 ? \"+\" + mod : String(mod)); const pd = probeStr(t.attrs); const av = t.attrs.map(a => getAttr(a) + mod); const al = t.attrs.map(a => attrNames[a] || a.toUpperCase()); const ts = av.map((v, i) => `${al[i]}:${v}`).join(\" / \"); return `<tr><td>${t.name}</td><td class=\"talent-probe\"><strong>${pd}</strong><br/><small>${ts}</small></td><td>${modStr}</td><td>${t.be}</td><td>${t.sf}</td><td>${fw}</td></tr>`; }).join(\"\");\nreturn `<table class=\"talent-table\"><thead><tr><th>Talent</th><th>Probe (Zielwerte)</th><th>Mod.</th><th>BE</th><th>Sf.</th><th>Fw</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                            }
                          ]
                        }
                      ],
                      "open": false
                    },
                    {
                      "type": "collapse",
                      "id": "3b19baf92a5a",
                      "heading": "Naturtalente",
                      "hasRule": false,
                      "conditioned": false,
                      "nested": [
                        {
                          "type": "group",
                          "id": "4bdb484a3b2b",
                          "properties": [],
                          "nested": [
                            {
                              "type": "property",
                              "id": "talent-natur-table",
                              "display": "",
                              "properties": [
                                "talente"
                              ],
                              "fallback": "",
                              "conditioned": false,
                              "callback": "const talents = [\n    { key: \"faehrtensuchen\", name: \"F√§hrtensuchen\", attrs: [\"mu\", \"in\", \"ge\"], be: \"Ja\", sf: \"C\" },\n    { key: \"fesseln\", name: \"Fesseln\", attrs: [\"kl\", \"ff\", \"kk\"], be: \"Evtl\", sf: \"A\" },\n    { key: \"fischen_angeln\", name: \"Fischen & Angeln\", attrs: [\"ff\", \"ge\", \"ko\"], be: \"Evtl\", sf: \"A\" },\n    { key: \"orientierung\", name: \"Orientierung\", attrs: [\"kl\", \"in\", \"in\"], be: \"Nein\", sf: \"B\" },\n    { key: \"pflanzenkunde\", name: \"Pflanzenkunde\", attrs: [\"kl\", \"ff\", \"ko\"], be: \"Evtl\", sf: \"C\" },\n    { key: \"tierkunde\", name: \"Tierkunde\", attrs: [\"mu\", \"mu\", \"ch\"], be: \"Ja\", sf: \"C\" },\n    { key: \"wildnisleben\", name: \"Wildnisleben\", attrs: [\"mu\", \"ge\", \"ko\"], be: \"Ja\", sf: \"C\" }\n];\nconst attrNames = { mu: \"MU\", kl: \"KL\", in: \"IN\", ch: \"CH\", ff: \"FF\", ge: \"GE\", ko: \"KO\", kk: \"KK\" };\nconst toValue = v => { if (v == null) return 0; if (typeof v === \"number\") return v; if (typeof v === \"string\") { const p = Number(v.trim()); return Number.isNaN(p) ? 0 : p; } if (typeof v === \"object\" && \"fw\" in v) return toValue(v.fw); return 0; };\nconst getAttr = k => { const a = monster.eigenschaften ?? {}; return toValue(a[k] ?? monster[k] ?? monster[`eigenschaften.${k}`]); };\nconst getFW = k => { const s = monster.talente ?? {}; if (k in s) return toValue(s[k]); if (`talente.${k}` in monster) return toValue(monster[`talente.${k}`]); return 0; };\nconst getMod = k => { const m = monster.talente_mod ?? {}; if (k in m) return toValue(m[k]); if (`talente_mod.${k}` in monster) return toValue(monster[`talente_mod.${k}`]); return 0; };\nconst probeStr = a => a.map(x => attrNames[x] || x.toUpperCase()).join(\"/\");\nconst renderRows = () => talents.map(t => { const fw = getFW(t.key); const mod = getMod(t.key); const modStr = mod === 0 ? \"0\" : (mod > 0 ? \"+\" + mod : String(mod)); const pd = probeStr(t.attrs); const av = t.attrs.map(a => getAttr(a) + mod); const al = t.attrs.map(a => attrNames[a] || a.toUpperCase()); const ts = av.map((v, i) => `${al[i]}:${v}`).join(\" / \"); return `<tr><td>${t.name}</td><td class=\"talent-probe\"><strong>${pd}</strong><br/><small>${ts}</small></td><td>${modStr}</td><td>${t.be}</td><td>${t.sf}</td><td>${fw}</td></tr>`; }).join(\"\");\nreturn `<table class=\"talent-table\"><thead><tr><th>Talent</th><th>Probe (Zielwerte)</th><th>Mod.</th><th>BE</th><th>Sf.</th><th>Fw</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                            }
                          ]
                        }
                      ],
                      "open": false
                    },
                    {
                      "type": "collapse",
                      "id": "4adad92a6a2a",
                      "heading": "Wissenstalente",
                      "hasRule": false,
                      "conditioned": false,
                      "nested": [
                        {
                          "type": "group",
                          "id": "693838c82bc9",
                          "properties": [],
                          "nested": [
                            {
                              "type": "property",
                              "id": "talent-wissen-table",
                              "display": "",
                              "properties": [
                                "talente"
                              ],
                              "fallback": "",
                              "conditioned": false,
                              "callback": "const talents = [\n    { key: \"brett_gluecksspiel\", name: \"Brett- & Gl√ºcksspiel\", attrs: [\"kl\", \"kl\", \"in\"], be: \"Nein\", sf: \"A\" },\n    { key: \"geographie\", name: \"Geographie\", attrs: [\"kl\", \"kl\", \"in\"], be: \"Nein\", sf: \"B\" },\n    { key: \"geschichtswissen\", name: \"Geschichtswissen\", attrs: [\"kl\", \"kl\", \"in\"], be: \"Nein\", sf: \"B\" },\n    { key: \"goetter_kulte\", name: \"G√∂tter & Kulte\", attrs: [\"kl\", \"kl\", \"in\"], be: \"Nein\", sf: \"B\" },\n    { key: \"kriegskunst\", name: \"Kriegskunst\", attrs: [\"mu\", \"kl\", \"in\"], be: \"Nein\", sf: \"B\" },\n    { key: \"magiekunde\", name: \"Magiekunde\", attrs: [\"kl\", \"kl\", \"in\"], be: \"Nein\", sf: \"C\" },\n    { key: \"mechanik\", name: \"Mechanik\", attrs: [\"kl\", \"kl\", \"ff\"], be: \"Nein\", sf: \"B\" },\n    { key: \"rechnen\", name: \"Rechnen\", attrs: [\"kl\", \"kl\", \"in\"], be: \"Nein\", sf: \"A\" },\n    { key: \"rechtskunde\", name: \"Rechtskunde\", attrs: [\"kl\", \"kl\", \"in\"], be: \"Nein\", sf: \"A\" },\n    { key: \"sagen_legenden\", name: \"Sagen & Legenden\", attrs: [\"kl\", \"kl\", \"in\"], be: \"Nein\", sf: \"B\" },\n    { key: \"sphaerenkunde\", name: \"Sph√§renkunde\", attrs: [\"kl\", \"kl\", \"in\"], be: \"Nein\", sf: \"B\" },\n    { key: \"sternkunde\", name: \"Sternkunde\", attrs: [\"kl\", \"kl\", \"in\"], be: \"Nein\", sf: \"A\" }\n];\nconst attrNames = { mu: \"MU\", kl: \"KL\", in: \"IN\", ch: \"CH\", ff: \"FF\", ge: \"GE\", ko: \"KO\", kk: \"KK\" };\nconst toValue = v => { if (v == null) return 0; if (typeof v === \"number\") return v; if (typeof v === \"string\") { const p = Number(v.trim()); return Number.isNaN(p) ? 0 : p; } if (typeof v === \"object\" && \"fw\" in v) return toValue(v.fw); return 0; };\nconst getAttr = k => { const a = monster.eigenschaften ?? {}; return toValue(a[k] ?? monster[k] ?? monster[`eigenschaften.${k}`]); };\nconst getFW = k => { const s = monster.talente ?? {}; if (k in s) return toValue(s[k]); if (`talente.${k}` in monster) return toValue(monster[`talente.${k}`]); return 0; };\nconst getMod = k => { const m = monster.talente_mod ?? {}; if (k in m) return toValue(m[k]); if (`talente_mod.${k}` in monster) return toValue(monster[`talente_mod.${k}`]); return 0; };\nconst probeStr = a => a.map(x => attrNames[x] || x.toUpperCase()).join(\"/\");\nconst renderRows = () => talents.map(t => { const fw = getFW(t.key); const mod = getMod(t.key); const modStr = mod === 0 ? \"0\" : (mod > 0 ? \"+\" + mod : String(mod)); const pd = probeStr(t.attrs); const av = t.attrs.map(a => getAttr(a) + mod); const al = t.attrs.map(a => attrNames[a] || a.toUpperCase()); const ts = av.map((v, i) => `${al[i]}:${v}`).join(\" / \"); return `<tr><td>${t.name}</td><td class=\"talent-probe\"><strong>${pd}</strong><br/><small>${ts}</small></td><td>${modStr}</td><td>${t.be}</td><td>${t.sf}</td><td>${fw}</td></tr>`; }).join(\"\");\nreturn `<table class=\"talent-table\"><thead><tr><th>Talent</th><th>Probe (Zielwerte)</th><th>Mod.</th><th>BE</th><th>Sf.</th><th>Fw</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                            }
                          ]
                        }
                      ],
                      "open": false
                    },
                    {
                      "type": "collapse",
                      "id": "1a38e839fb5b",
                      "heading": "Handwerkstalente",
                      "hasRule": false,
                      "conditioned": false,
                      "nested": [
                        {
                          "type": "group",
                          "id": "1a6a887bc9bb",
                          "properties": [],
                          "nested": [
                            {
                              "type": "property",
                              "id": "talent-handwerk-table",
                              "display": "",
                              "properties": [
                                "talente"
                              ],
                              "fallback": "",
                              "conditioned": false,
                              "callback": "const talents = [\n    { key: \"alchimie\", name: \"Alchimie\", attrs: [\"mu\", \"kl\", \"ff\"], be: \"Ja\", sf: \"C\" },\n    { key: \"boote_schiffe\", name: \"Boote & Schiffe\", attrs: [\"ff\", \"ge\", \"kk\"], be: \"Ja\", sf: \"B\" },\n    { key: \"fahrzeuge\", name: \"Fahrzeuge\", attrs: [\"ch\", \"ff\", \"ko\"], be: \"Ja\", sf: \"A\" },\n    { key: \"handel\", name: \"Handel\", attrs: [\"kl\", \"in\", \"ch\"], be: \"Nein\", sf: \"B\" },\n    { key: \"heilkunde_gift\", name: \"Heilkunde Gift\", attrs: [\"mu\", \"kl\", \"in\"], be: \"Ja\", sf: \"B\" },\n    { key: \"heilkunde_krankheiten\", name: \"Heilkunde Krankheiten\", attrs: [\"mu\", \"in\", \"ko\"], be: \"Ja\", sf: \"B\" },\n    { key: \"heilkunde_seele\", name: \"Heilkunde Seele\", attrs: [\"in\", \"ch\", \"ko\"], be: \"Nein\", sf: \"B\" },\n    { key: \"heilkunde_wunden\", name: \"Heilkunde Wunden\", attrs: [\"kl\", \"ff\", \"ff\"], be: \"Ja\", sf: \"D\" },\n    { key: \"holzbearbeitung\", name: \"Holzbearbeitung\", attrs: [\"ff\", \"ge\", \"kk\"], be: \"Ja\", sf: \"B\" },\n    { key: \"lebensmittelbearbeitung\", name: \"Lebensmittelbearbeitung\", attrs: [\"in\", \"ff\", \"ff\"], be: \"Ja\", sf: \"A\" },\n    { key: \"lederbearbeitung\", name: \"Lederbearbeitung\", attrs: [\"ff\", \"ge\", \"ko\"], be: \"Ja\", sf: \"B\" },\n    { key: \"malen_zeichnen\", name: \"Malen & Zeichnen\", attrs: [\"in\", \"ff\", \"ff\"], be: \"Ja\", sf: \"A\" },\n    { key: \"metallbearbeitung\", name: \"Metallbearbeitung\", attrs: [\"ff\", \"ko\", \"kk\"], be: \"Ja\", sf: \"C\" },\n    { key: \"musizieren\", name: \"Musizieren\", attrs: [\"ch\", \"ff\", \"ko\"], be: \"Ja\", sf: \"A\" },\n    { key: \"schloesserknacken\", name: \"Schl√∂sserknacken\", attrs: [\"in\", \"ff\", \"ff\"], be: \"Ja\", sf: \"C\" },\n    { key: \"steinbearbeitung\", name: \"Steinbearbeitung\", attrs: [\"ff\", \"ff\", \"kk\"], be: \"Ja\", sf: \"A\" },\n    { key: \"stoffbearbeitung\", name: \"Stoffbearbeitung\", attrs: [\"kl\", \"ff\", \"ff\"], be: \"Ja\", sf: \"A\" }\n];\nconst attrNames = { mu: \"MU\", kl: \"KL\", in: \"IN\", ch: \"CH\", ff: \"FF\", ge: \"GE\", ko: \"KO\", kk: \"KK\" };\nconst toValue = v => { if (v == null) return 0; if (typeof v === \"number\") return v; if (typeof v === \"string\") { const p = Number(v.trim()); return Number.isNaN(p) ? 0 : p; } if (typeof v === \"object\" && \"fw\" in v) return toValue(v.fw); return 0; };\nconst getAttr = k => { const a = monster.eigenschaften ?? {}; return toValue(a[k] ?? monster[k] ?? monster[`eigenschaften.${k}`]); };\nconst getFW = k => { const s = monster.talente ?? {}; if (k in s) return toValue(s[k]); if (`talente.${k}` in monster) return toValue(monster[`talente.${k}`]); return 0; };\nconst getMod = k => { const m = monster.talente_mod ?? {}; if (k in m) return toValue(m[k]); if (`talente_mod.${k}` in monster) return toValue(monster[`talente_mod.${k}`]); return 0; };\nconst probeStr = a => a.map(x => attrNames[x] || x.toUpperCase()).join(\"/\");\nconst renderRows = () => talents.map(t => { const fw = getFW(t.key); const mod = getMod(t.key); const modStr = mod === 0 ? \"0\" : (mod > 0 ? \"+\" + mod : String(mod)); const pd = probeStr(t.attrs); const av = t.attrs.map(a => getAttr(a) + mod); const al = t.attrs.map(a => attrNames[a] || a.toUpperCase()); const ts = av.map((v, i) => `${al[i]}:${v}`).join(\" / \"); return `<tr><td>${t.name}</td><td class=\"talent-probe\"><strong>${pd}</strong><br/><small>${ts}</small></td><td>${modStr}</td><td>${t.be}</td><td>${t.sf}</td><td>${fw}</td></tr>`; }).join(\"\");\nreturn `<table class=\"talent-table\"><thead><tr><th>Talent</th><th>Probe (Zielwerte)</th><th>Mod.</th><th>BE</th><th>Sf.</th><th>Fw</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                            }
                          ]
                        }
                      ],
                      "open": false
                    }
                  ]
                }
              ],
              "open": true
            }
          ],
          "heading": "Talente",
          "hasRule": false
        },
        {
          "type": "group",
          "id": "da696afa5a5a",
          "properties": [],
          "nested": [
            {
              "type": "collapse",
              "id": "b859b8283aa9",
              "heading": "",
              "hasRule": false,
              "conditioned": false,
              "nested": [
                {
                  "type": "group",
                  "id": "693b79e969da",
                  "properties": [],
                  "nested": [
                    {
                      "type": "property",
                      "id": "kampftechnik-table",
                      "display": "",
                      "properties": [
                        "kampftechniken"
                      ],
                      "fallback": "",
                      "conditioned": false,
                      "callback": "const techniques = [\n    { key: \"armbr√ºste\", name: \"Armbr√ºste\", attrLabel: \"FF\", attrKeys: [\"ff\"], sf: \"B\", ranged: true, parry: false },\n    { key: \"blasrohre\", name: \"Blasrohre\", attrLabel: \"FF\", attrKeys: [\"ff\"], sf: \"B\", ranged: true, parry: false },\n    { key: \"b√∂gen\", name: \"B√∂gen\", attrLabel: \"FF\", attrKeys: [\"ff\"], sf: \"C\", ranged: true, parry: false },\n    { key: \"diskusse\", name: \"Diskusse\", attrLabel: \"FF\", attrKeys: [\"ff\"], sf: \"B\", ranged: true, parry: false },\n    { key: \"dolche\", name: \"Dolche\", attrLabel: \"GE\", attrKeys: [\"ge\"], sf: \"B\", ranged: false, parry: true },\n    { key: \"f√§cher\", name: \"F√§cher\", attrLabel: \"GE\", attrKeys: [\"ge\"], sf: \"C\", ranged: false, parry: true },\n    { key: \"fechtwaffen\", name: \"Fechtwaffen\", attrLabel: \"GE\", attrKeys: [\"ge\"], sf: \"C\", ranged: false, parry: true },\n    { key: \"hiebwaffen\", name: \"Hiebwaffen\", attrLabel: \"KK\", attrKeys: [\"kk\"], sf: \"C\", ranged: false, parry: true },\n    { key: \"kettenwaffen\", name: \"Kettenwaffen\", attrLabel: \"KK\", attrKeys: [\"kk\"], sf: \"C\", ranged: false, parry: false },\n    { key: \"lanzen\", name: \"Lanzen\", attrLabel: \"KK\", attrKeys: [\"kk\"], sf: \"B\", ranged: false, parry: true },\n    { key: \"peitschen\", name: \"Peitschen\", attrLabel: \"GE\", attrKeys: [\"ge\"], sf: \"B\", ranged: false, parry: false },\n    { key: \"raufen\", name: \"Raufen\", attrLabel: \"GE/KK\", attrKeys: [\"ge\", \"kk\"], sf: \"B\", ranged: false, parry: true },\n    { key: \"schilde\", name: \"Schilde\", attrLabel: \"KK\", attrKeys: [\"kk\"], sf: \"C\", ranged: false, parry: true },\n    { key: \"schleudern\", name: \"Schleudern\", attrLabel: \"FF\", attrKeys: [\"ff\"], sf: \"B\", ranged: true, parry: false },\n    { key: \"schwerter\", name: \"Schwerter\", attrLabel: \"GE/KK\", attrKeys: [\"ge\", \"kk\"], sf: \"C\", ranged: false, parry: true },\n    { key: \"stangenwaffen\", name: \"Stangenwaffen\", attrLabel: \"GE/KK\", attrKeys: [\"ge\", \"kk\"], sf: \"C\", ranged: false, parry: true },\n    { key: \"wurfwaffen\", name: \"Wurfwaffen\", attrLabel: \"FF\", attrKeys: [\"ff\"], sf: \"B\", ranged: true, parry: false },\n    { key: \"zweihandhiebwaffen\", name: \"Zweihandhiebwaffen\", attrLabel: \"KK\", attrKeys: [\"kk\"], sf: \"C\", ranged: false, parry: true },\n    { key: \"zweihandschwerter\", name: \"Zweihandschwerter\", attrLabel: \"KK\", attrKeys: [\"kk\"], sf: \"C\", ranged: false, parry: true }\n];\nconst escapeHtml = str => (str ?? \"\").replace(/[&<>\"']/g, c => ({ \"&\": \"&amp;\", \"<\": \"&lt;\", \">\": \"&gt;\", '\"': \"&quot;\", \"'\": \"&#39;\" }[c] || c));\nconst toUmlaut = s => s.replace(/oe/g, '√∂').replace(/ae/g, '√§').replace(/ue/g, '√º');\nconst toAscii = s => s.replace(/√∂/g, 'oe').replace(/√§/g, 'ae').replace(/√º/g, 'ue');\nconst toNumber = value => {\n    if (typeof value === \"number\") {\n        return value;\n    }\n    if (typeof value === \"string\") {\n        const parsed = Number(value.trim());\n        return Number.isFinite(parsed) ? parsed : NaN;\n    }\n    return NaN;\n};\nconst toValue = value => {\n    if (value === undefined || value === null) {\n        return null;\n    }\n    if (typeof value === \"object\" && \"ktw\" in value) {\n        return toValue(value.ktw);\n    }\n    const num = toNumber(value);\n    return Number.isFinite(num) ? num : null;\n};\nconst getKtw = key => {\n    const store = monster.kampftechniken ?? {};\n    if (key in store) {\n        const val = toValue(store[key]);\n        if (Number.isFinite(val)) return val;\n    }\n    for (const storeKey in store) {\n        if (toUmlaut(storeKey) === key) {\n            const val = toValue(store[storeKey]);\n            if (Number.isFinite(val)) return val;\n        }\n    }\n    const keyAscii = toAscii(key);\n    if (keyAscii in store) {\n        const val = toValue(store[keyAscii]);\n        if (Number.isFinite(val)) return val;\n    }\n    for (const storeKey in store) {\n        if (storeKey.toLowerCase() === key || storeKey.toLowerCase() === keyAscii) {\n            const val = toValue(store[storeKey]);\n            if (Number.isFinite(val)) return val;\n        }\n    }\n    const nestedKey = `kampftechniken.${key}`;\n    if (nestedKey in monster) {\n        const val = toValue(monster[nestedKey]);\n        if (Number.isFinite(val)) return val;\n    }\n    return 6;\n};\nconst attrs = monster.eigenschaften ?? {};\nconst getAttr = key => toNumber(attrs[key] ?? monster[key] ?? monster[`eigenschaften.${key}`]);\nconst bonusFromAttr = key => {\n    const val = getAttr(key);\n    if (!Number.isFinite(val) || val <= 8) {\n        return 0;\n    }\n    return Math.round((val - 8) / 3);\n};\nconst calcAt = ktw => ktw + bonusFromAttr(\"mu\");\nconst calcFk = ktw => ktw + bonusFromAttr(\"ff\");\nconst calcPa = (ktw, attrKeys) => {\n    if (!attrKeys.length) {\n        return NaN;\n    }\n    const attrBonus = attrKeys.reduce((max, key) => Math.max(max, bonusFromAttr(key)), 0);\n    return Math.ceil(ktw / 2) + attrBonus;\n};\nconst renderCheck = (value) => {\n    if (!Number.isFinite(value)) {\n        return \"-\";\n    }\n    return String(value);\n};\nconst renderRows = () => techniques.map(tech => {\n    const raw = getKtw(tech.key);\n    const ktw = Number.isFinite(raw) ? raw : 6;\n    const atkValue = tech.ranged ? calcFk(ktw) : calcAt(ktw);\n    const paValue = tech.parry ? calcPa(ktw, tech.attrKeys) : NaN;\n    const atkLabel = tech.ranged ? \"FK\" : \"AT\";\n    const atkCell = renderCheck(atkValue);\n    const paCell = tech.parry ? renderCheck(paValue) : \"-\";\n    const safeName = escapeHtml(tech.name);\n    const safeAttr = escapeHtml(tech.attrLabel);\n    const safeSf = escapeHtml(tech.sf);\n    return `<tr><td>${safeName}</td><td>${safeAttr}</td><td>${safeSf}</td><td>${ktw}</td><td>${atkCell}</td><td>${paCell}</td></tr>`;\n}).join(\"\");\nreturn `<table class=\"kampftechnik-table\"><thead><tr><th>Kampftechnik</th><th>Leiteig.</th><th>Sf.</th><th>Ktw.</th><th>AT/FK</th><th>PA</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                    }
                  ]
                }
              ],
              "open": false
            }
          ],
          "heading": "Kampftechniken",
          "hasRule": false
        },
        {
          "type": "group",
          "id": "magie-section",
          "properties": [
            "zauber",
            "rituale",
            "zaubertricks"
          ],
          "conditioned": true,
          "nested": [
            {
              "type": "collapse",
              "id": "zauber-collapse",
              "heading": "Zauber",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "zauber-table",
                  "display": "",
                  "properties": [
                    "zauber"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const spells = monster.zauber ?? [];\nif (!Array.isArray(spells) || spells.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 9;\nconst renderRows = () => spells.map(s => {\n  let rows = `<tr class=\"spell-main\"><td>${esc(s.name)}</td><td>${esc(s.probe)}</td><td>${esc(s.zauberdauer)}</td><td>${esc(s.asp)}</td><td>${esc(s.rw)}</td><td>${esc(s.wirkungsdauer)}</td><td>${esc(s.merkmal)}</td><td>${esc(s.sf)}</td><td>${esc(s.fw ?? '0')}</td></tr>`;\n  if (s.wirkung) rows += `<tr class=\"spell-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Wirkung:</strong> ${esc(s.wirkung)}</td></tr>`;\n  if (s.reversalis) rows += `<tr class=\"spell-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;font-style:italic;\"><strong>Reversalis:</strong> ${esc(s.reversalis)}</td></tr>`;\n  const erw = s.erweiterungen ?? [];\n  erw.forEach((e, i) => { const txt = typeof e === 'object' ? (e.name ? `${e.name}: ${e.beschreibung ?? ''}` : JSON.stringify(e)) : e; rows += `<tr class=\"spell-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.85em;\"><strong>Erw. ${i+1}:</strong> ${esc(txt)}</td></tr>`; });\n  return rows;\n}).join('');\nreturn `<table class=\"zauber-table\"><thead><tr><th>Zauber</th><th>Probe</th><th>Zauberdauer</th><th>AsP-Kosten</th><th>RW</th><th>Wirkungsdauer</th><th>Merkmal</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": true
            },
            {
              "type": "collapse",
              "id": "rituale-collapse",
              "heading": "Rituale",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "rituale-table",
                  "display": "",
                  "properties": [
                    "rituale"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const rituals = monster.rituale ?? [];\nif (!Array.isArray(rituals) || rituals.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 9;\nconst renderRows = () => rituals.map(r => {\n  let rows = `<tr class=\"spell-main\"><td>${esc(r.name)}</td><td>${esc(r.probe)}</td><td>${esc(r.ritualdauer)}</td><td>${esc(r.asp)}</td><td>${esc(r.rw)}</td><td>${esc(r.wirkungsdauer)}</td><td>${esc(r.merkmal)}</td><td>${esc(r.sf)}</td><td>${esc(r.fw ?? '0')}</td></tr>`;\n  if (r.wirkung) rows += `<tr class=\"spell-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Wirkung:</strong> ${esc(r.wirkung)}</td></tr>`;\n  if (r.reversalis) rows += `<tr class=\"spell-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;font-style:italic;\"><strong>Reversalis:</strong> ${esc(r.reversalis)}</td></tr>`;\n  const erw = r.erweiterungen ?? [];\n  erw.forEach((e, i) => { const txt = typeof e === 'object' ? (e.name ? `${e.name}: ${e.beschreibung ?? ''}` : JSON.stringify(e)) : e; rows += `<tr class=\"spell-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.85em;\"><strong>Erw. ${i+1}:</strong> ${esc(txt)}</td></tr>`; });\n  return rows;\n}).join('');\nreturn `<table class=\"rituale-table\"><thead><tr><th>Ritual</th><th>Probe</th><th>Ritualdauer</th><th>AsP-Kosten</th><th>RW</th><th>Wirkungsdauer</th><th>Merkmal</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            },
            {
              "type": "collapse",
              "id": "zaubertricks-collapse",
              "heading": "Zaubertricks",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "zaubertricks-table",
                  "display": "",
                  "properties": [
                    "zaubertricks"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const tricks = monster.zaubertricks ?? [];\nif (!Array.isArray(tricks) || tricks.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 9;\nconst renderRows = () => tricks.map(t => {\n  let rows = `<tr class=\"spell-main\"><td>${esc(t.name)}</td><td>${esc(t.probe)}</td><td>${esc(t.zauberdauer)}</td><td>${esc(t.asp)}</td><td>${esc(t.rw)}</td><td>${esc(t.wirkungsdauer)}</td><td>${esc(t.merkmal)}</td><td>${esc(t.sf)}</td><td>${esc(t.fw ?? '0')}</td></tr>`;\n  if (t.wirkung) rows += `<tr class=\"spell-detail\"><td colspan=\"${cols}\"><strong>Wirkung:</strong> ${esc(t.wirkung)}</td></tr>`;\n  const erw = t.erweiterungen ?? [];\n  erw.forEach((e, i) => { rows += `<tr class=\"spell-detail\"><td colspan=\"${cols}\"><strong>Erweiterung ${i+1}:</strong> ${esc(e)}</td></tr>`; });\n  return rows;\n}).join('');\nreturn `<table class=\"zaubertricks-table\"><thead><tr><th>Zaubertrick</th><th>Probe</th><th>Zauberdauer</th><th>AsP-Kosten</th><th>RW</th><th>Wirkungsdauer</th><th>Merkmal</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            }
          ],
          "heading": "Magie",
          "hasRule": false
        },
        {
          "type": "group",
          "id": "magische-handlungen-section",
          "properties": [
            "magische_handlungen",
            "elfenlieder",
            "hexenfluche",
            "zaubertanze",
            "zaubermelodien",
            "zauberrunen",
            "schelmenstreiche",
            "animistenkraefte",
            "geodenrituale",
            "herrschaftsrituale",
            "zibiljarituale",
            "goblinrituale",
            "bannzeichen"
          ],
          "conditioned": true,
          "nested": [
            {
              "type": "collapse",
              "id": "magische-handlungen-generic-collapse",
              "heading": "Allgemeine Magische Handlungen",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "magische-handlungen-generic-table",
                  "display": "",
                  "properties": [
                    "magische_handlungen"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const items = monster.magische_handlungen ?? [];\nif (!Array.isArray(items) || items.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 7;\nconst renderRows = () => items.map(h => {\n  let rows = `<tr class=\"mh-main\"><td>${esc(h.name)}</td><td>${esc(h.typ ?? '-')}</td><td>${esc(h.probe)}</td><td>${esc(h.dauer ?? '-')}</td><td>${esc(h.asp)}</td><td>${esc(h.merkmal)}</td><td>${esc(h.sf ?? '-')}</td></tr>`;\n  if (h.wirkung) rows += `<tr class=\"mh-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Wirkung:</strong> ${esc(h.wirkung)}</td></tr>`;\n  return rows;\n}).join('');\nreturn `<table class=\"mh-table\"><thead><tr><th>Name</th><th>Typ</th><th>Probe</th><th>Dauer</th><th>AsP</th><th>Merkmal</th><th>Sf.</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            },
            {
              "type": "collapse",
              "id": "elfenlieder-collapse",
              "heading": "Elfenlieder",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "elfenlieder-table",
                  "display": "",
                  "properties": [
                    "elfenlieder"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const items = monster.elfenlieder ?? [];\nif (!Array.isArray(items) || items.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 7;\nconst renderRows = () => items.map(h => {\n  let rows = `<tr class=\"mh-main\"><td>${esc(h.name)}</td><td>${esc(h.probe)}</td><td>${esc(h.dauer ?? h.talent)}</td><td>${esc(h.asp)}</td><td>${esc(h.merkmal)}</td><td>${esc(h.sf)}</td><td>${esc(h.fw ?? '0')}</td></tr>`;\n  if (h.wirkung) rows += `<tr class=\"mh-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Wirkung:</strong> ${esc(h.wirkung)}</td></tr>`;\n  return rows;\n}).join('');\nreturn `<table class=\"mh-table\"><thead><tr><th>Elfenlied</th><th>Probe</th><th>Dauer</th><th>AsP</th><th>Merkmal</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            },
            {
              "type": "collapse",
              "id": "hexenfluche-collapse",
              "heading": "Hexenfl√ºche",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "hexenfluche-table",
                  "display": "",
                  "properties": [
                    "hexenfluche"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const items = monster.hexenfluche ?? [];\nif (!Array.isArray(items) || items.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 7;\nconst renderRows = () => items.map(h => {\n  let rows = `<tr class=\"mh-main\"><td>${esc(h.name)}</td><td>${esc(h.probe)}</td><td>${esc(h.dauer ?? h.talent)}</td><td>${esc(h.asp)}</td><td>${esc(h.merkmal)}</td><td>${esc(h.sf)}</td><td>${esc(h.fw ?? '0')}</td></tr>`;\n  if (h.wirkung) rows += `<tr class=\"mh-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Wirkung:</strong> ${esc(h.wirkung)}</td></tr>`;\n  return rows;\n}).join('');\nreturn `<table class=\"mh-table\"><thead><tr><th>Hexenfluch</th><th>Probe</th><th>Dauer</th><th>AsP</th><th>Merkmal</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            },
            {
              "type": "collapse",
              "id": "zaubertanze-collapse",
              "heading": "Zaubert√§nze",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "zaubertanze-table",
                  "display": "",
                  "properties": [
                    "zaubertanze"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const items = monster.zaubertanze ?? [];\nif (!Array.isArray(items) || items.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 7;\nconst renderRows = () => items.map(h => {\n  let rows = `<tr class=\"mh-main\"><td>${esc(h.name)}</td><td>${esc(h.probe)}</td><td>${esc(h.dauer ?? h.talent)}</td><td>${esc(h.asp)}</td><td>${esc(h.merkmal)}</td><td>${esc(h.sf)}</td><td>${esc(h.fw ?? '0')}</td></tr>`;\n  if (h.wirkung) rows += `<tr class=\"mh-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Wirkung:</strong> ${esc(h.wirkung)}</td></tr>`;\n  return rows;\n}).join('');\nreturn `<table class=\"mh-table\"><thead><tr><th>Zaubertanz</th><th>Probe</th><th>Dauer</th><th>AsP</th><th>Merkmal</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            },
            {
              "type": "collapse",
              "id": "zaubermelodien-collapse",
              "heading": "Zaubermelodien",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "zaubermelodien-table",
                  "display": "",
                  "properties": [
                    "zaubermelodien"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const items = monster.zaubermelodien ?? [];\nif (!Array.isArray(items) || items.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 7;\nconst renderRows = () => items.map(h => {\n  let rows = `<tr class=\"mh-main\"><td>${esc(h.name)}</td><td>${esc(h.probe)}</td><td>${esc(h.dauer ?? h.talent)}</td><td>${esc(h.asp)}</td><td>${esc(h.merkmal)}</td><td>${esc(h.sf)}</td><td>${esc(h.fw ?? '0')}</td></tr>`;\n  if (h.wirkung) rows += `<tr class=\"mh-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Wirkung:</strong> ${esc(h.wirkung)}</td></tr>`;\n  return rows;\n}).join('');\nreturn `<table class=\"mh-table\"><thead><tr><th>Zaubermelodie</th><th>Probe</th><th>Dauer</th><th>AsP</th><th>Merkmal</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            },
            {
              "type": "collapse",
              "id": "zauberrunen-collapse",
              "heading": "Zauberrunen",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "zauberrunen-table",
                  "display": "",
                  "properties": [
                    "zauberrunen"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const items = monster.zauberrunen ?? [];\nif (!Array.isArray(items) || items.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 7;\nconst renderRows = () => items.map(h => {\n  let rows = `<tr class=\"mh-main\"><td>${esc(h.name)}</td><td>${esc(h.probe)}</td><td>${esc(h.dauer ?? h.talent)}</td><td>${esc(h.asp)}</td><td>${esc(h.merkmal)}</td><td>${esc(h.sf)}</td><td>${esc(h.fw ?? '0')}</td></tr>`;\n  if (h.wirkung) rows += `<tr class=\"mh-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Wirkung:</strong> ${esc(h.wirkung)}</td></tr>`;\n  return rows;\n}).join('');\nreturn `<table class=\"mh-table\"><thead><tr><th>Zauberrune</th><th>Probe</th><th>Dauer</th><th>AsP</th><th>Merkmal</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            },
            {
              "type": "collapse",
              "id": "schelmenstreiche-collapse",
              "heading": "Schelmenstreiche",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "schelmenstreiche-table",
                  "display": "",
                  "properties": [
                    "schelmenstreiche"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const items = monster.schelmenstreiche ?? [];\nif (!Array.isArray(items) || items.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 7;\nconst renderRows = () => items.map(h => {\n  let rows = `<tr class=\"mh-main\"><td>${esc(h.name)}</td><td>${esc(h.probe)}</td><td>${esc(h.dauer ?? h.talent)}</td><td>${esc(h.asp)}</td><td>${esc(h.merkmal)}</td><td>${esc(h.sf)}</td><td>${esc(h.fw ?? '0')}</td></tr>`;\n  if (h.wirkung) rows += `<tr class=\"mh-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Wirkung:</strong> ${esc(h.wirkung)}</td></tr>`;\n  return rows;\n}).join('');\nreturn `<table class=\"mh-table\"><thead><tr><th>Schelmenstreich</th><th>Probe</th><th>Dauer</th><th>AsP</th><th>Merkmal</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            },
            {
              "type": "collapse",
              "id": "animistenkraefte-collapse",
              "heading": "Animistenkr√§fte",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "animistenkraefte-table",
                  "display": "",
                  "properties": [
                    "animistenkraefte"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const items = monster.animistenkraefte ?? [];\nif (!Array.isArray(items) || items.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 7;\nconst renderRows = () => items.map(h => {\n  let rows = `<tr class=\"mh-main\"><td>${esc(h.name)}</td><td>${esc(h.probe)}</td><td>${esc(h.dauer ?? h.talent)}</td><td>${esc(h.asp)}</td><td>${esc(h.merkmal)}</td><td>${esc(h.sf)}</td><td>${esc(h.fw ?? '0')}</td></tr>`;\n  if (h.wirkung) rows += `<tr class=\"mh-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Wirkung:</strong> ${esc(h.wirkung)}</td></tr>`;\n  return rows;\n}).join('');\nreturn `<table class=\"mh-table\"><thead><tr><th>Animistenkraft</th><th>Probe</th><th>Dauer</th><th>AsP</th><th>Merkmal</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            },
            {
              "type": "collapse",
              "id": "geodenrituale-collapse",
              "heading": "Geodenrituale",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "geodenrituale-table",
                  "display": "",
                  "properties": [
                    "geodenrituale"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const items = monster.geodenrituale ?? [];\nif (!Array.isArray(items) || items.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 7;\nconst renderRows = () => items.map(h => {\n  let rows = `<tr class=\"mh-main\"><td>${esc(h.name)}</td><td>${esc(h.probe)}</td><td>${esc(h.dauer ?? h.talent)}</td><td>${esc(h.asp)}</td><td>${esc(h.merkmal)}</td><td>${esc(h.sf)}</td><td>${esc(h.fw ?? '0')}</td></tr>`;\n  if (h.wirkung) rows += `<tr class=\"mh-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Wirkung:</strong> ${esc(h.wirkung)}</td></tr>`;\n  return rows;\n}).join('');\nreturn `<table class=\"mh-table\"><thead><tr><th>Geodenritual</th><th>Probe</th><th>Dauer</th><th>AsP</th><th>Merkmal</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            },
            {
              "type": "collapse",
              "id": "herrschaftsrituale-collapse",
              "heading": "Herrschaftsrituale",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "herrschaftsrituale-table",
                  "display": "",
                  "properties": [
                    "herrschaftsrituale"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const items = monster.herrschaftsrituale ?? [];\nif (!Array.isArray(items) || items.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 7;\nconst renderRows = () => items.map(h => {\n  let rows = `<tr class=\"mh-main\"><td>${esc(h.name)}</td><td>${esc(h.probe)}</td><td>${esc(h.dauer ?? h.talent)}</td><td>${esc(h.asp)}</td><td>${esc(h.merkmal)}</td><td>${esc(h.sf)}</td><td>${esc(h.fw ?? '0')}</td></tr>`;\n  if (h.wirkung) rows += `<tr class=\"mh-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Wirkung:</strong> ${esc(h.wirkung)}</td></tr>`;\n  return rows;\n}).join('');\nreturn `<table class=\"mh-table\"><thead><tr><th>Herrschaftsritual</th><th>Probe</th><th>Dauer</th><th>AsP</th><th>Merkmal</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            },
            {
              "type": "collapse",
              "id": "zibiljarituale-collapse",
              "heading": "Zibiljarituale",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "zibiljarituale-table",
                  "display": "",
                  "properties": [
                    "zibiljarituale"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const items = monster.zibiljarituale ?? [];\nif (!Array.isArray(items) || items.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 7;\nconst renderRows = () => items.map(h => {\n  let rows = `<tr class=\"mh-main\"><td>${esc(h.name)}</td><td>${esc(h.probe)}</td><td>${esc(h.dauer ?? h.talent)}</td><td>${esc(h.asp)}</td><td>${esc(h.merkmal)}</td><td>${esc(h.sf)}</td><td>${esc(h.fw ?? '0')}</td></tr>`;\n  if (h.wirkung) rows += `<tr class=\"mh-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Wirkung:</strong> ${esc(h.wirkung)}</td></tr>`;\n  return rows;\n}).join('');\nreturn `<table class=\"mh-table\"><thead><tr><th>Zibiljaritual</th><th>Probe</th><th>Dauer</th><th>AsP</th><th>Merkmal</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            },
            {
              "type": "collapse",
              "id": "goblinrituale-collapse",
              "heading": "Goblinrituale",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "goblinrituale-table",
                  "display": "",
                  "properties": [
                    "goblinrituale"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const items = monster.goblinrituale ?? [];\nif (!Array.isArray(items) || items.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 7;\nconst renderRows = () => items.map(h => {\n  let rows = `<tr class=\"mh-main\"><td>${esc(h.name)}</td><td>${esc(h.probe)}</td><td>${esc(h.dauer ?? h.talent)}</td><td>${esc(h.asp)}</td><td>${esc(h.merkmal)}</td><td>${esc(h.sf)}</td><td>${esc(h.fw ?? '0')}</td></tr>`;\n  if (h.wirkung) rows += `<tr class=\"mh-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Wirkung:</strong> ${esc(h.wirkung)}</td></tr>`;\n  return rows;\n}).join('');\nreturn `<table class=\"mh-table\"><thead><tr><th>Goblinritual</th><th>Probe</th><th>Dauer</th><th>AsP</th><th>Merkmal</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            },
            {
              "type": "collapse",
              "id": "bannzeichen-collapse",
              "heading": "Bannzeichen",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "bannzeichen-table",
                  "display": "",
                  "properties": [
                    "bannzeichen"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const items = monster.bannzeichen ?? [];\nif (!Array.isArray(items) || items.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 7;\nconst renderRows = () => items.map(h => {\n  let rows = `<tr class=\"mh-main\"><td>${esc(h.name)}</td><td>${esc(h.probe)}</td><td>${esc(h.dauer ?? h.talent)}</td><td>${esc(h.asp)}</td><td>${esc(h.merkmal)}</td><td>${esc(h.sf)}</td><td>${esc(h.fw ?? '0')}</td></tr>`;\n  if (h.wirkung) rows += `<tr class=\"mh-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Wirkung:</strong> ${esc(h.wirkung)}</td></tr>`;\n  return rows;\n}).join('');\nreturn `<table class=\"mh-table\"><thead><tr><th>Bannzeichen</th><th>Probe</th><th>Dauer</th><th>AsP</th><th>Merkmal</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            }
          ],
          "heading": "Magische Handlungen",
          "hasRule": false
        },
        {
          "type": "group",
          "id": "karma-section",
          "properties": [
            "liturgien",
            "zeremonien",
            "segnungen"
          ],
          "conditioned": true,
          "nested": [
            {
              "type": "collapse",
              "id": "liturgien-collapse",
              "heading": "Liturgien",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "liturgien-table",
                  "display": "",
                  "properties": [
                    "liturgien"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const liturgies = monster.liturgien ?? [];\nif (!Array.isArray(liturgies) || liturgies.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 9;\nconst renderRows = () => liturgies.map(l => {\n  let rows = `<tr class=\"spell-main\"><td>${esc(l.name)}</td><td>${esc(l.probe)}</td><td>${esc(l.liturgiedauer)}</td><td>${esc(l.kap)}</td><td>${esc(l.rw)}</td><td>${esc(l.wirkungsdauer)}</td><td>${esc(l.verbreitung ?? l.aspekt)}</td><td>${esc(l.sf)}</td><td>${esc(l.fw ?? '0')}</td></tr>`;\n  if (l.wirkung) rows += `<tr class=\"spell-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Wirkung:</strong> ${esc(l.wirkung)}</td></tr>`;\n  const erw = l.erweiterungen ?? [];\n  erw.forEach((e, i) => { const txt = typeof e === 'object' ? (e.name ? `${e.name}: ${e.beschreibung ?? ''}` : JSON.stringify(e)) : e; rows += `<tr class=\"spell-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.85em;\"><strong>Erw. ${i+1}:</strong> ${esc(txt)}</td></tr>`; });\n  return rows;\n}).join('');\nreturn `<table class=\"liturgien-table\"><thead><tr><th>Liturgie</th><th>Probe</th><th>Liturgiedauer</th><th>KaP-Kosten</th><th>RW</th><th>Wirkungsdauer</th><th>Verbreitung</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            },
            {
              "type": "collapse",
              "id": "zeremonien-collapse",
              "heading": "Zeremonien",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "zeremonien-table",
                  "display": "",
                  "properties": [
                    "zeremonien"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const ceremonies = monster.zeremonien ?? [];\nif (!Array.isArray(ceremonies) || ceremonies.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 9;\nconst renderRows = () => ceremonies.map(c => {\n  let rows = `<tr class=\"spell-main\"><td>${esc(c.name)}</td><td>${esc(c.probe)}</td><td>${esc(c.zeremoniedauer)}</td><td>${esc(c.kap)}</td><td>${esc(c.rw)}</td><td>${esc(c.wirkungsdauer)}</td><td>${esc(c.verbreitung ?? c.aspekt)}</td><td>${esc(c.sf)}</td><td>${esc(c.fw ?? '0')}</td></tr>`;\n  if (c.wirkung) rows += `<tr class=\"spell-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.9em;\"><strong>Wirkung:</strong> ${esc(c.wirkung)}</td></tr>`;\n  const erw = c.erweiterungen ?? [];\n  erw.forEach((e, i) => { const txt = typeof e === 'object' ? (e.name ? `${e.name}: ${e.beschreibung ?? ''}` : JSON.stringify(e)) : e; rows += `<tr class=\"spell-detail\"><td colspan=\"${cols}\" style=\"padding-left:1em;font-size:0.85em;\"><strong>Erw. ${i+1}:</strong> ${esc(txt)}</td></tr>`; });\n  return rows;\n}).join('');\nreturn `<table class=\"zeremonien-table\"><thead><tr><th>Zeremonie</th><th>Probe</th><th>Zeremoniedauer</th><th>KaP-Kosten</th><th>RW</th><th>Wirkungsdauer</th><th>Verbreitung</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            },
            {
              "type": "collapse",
              "id": "segnungen-collapse",
              "heading": "Segnungen",
              "hasRule": false,
              "conditioned": true,
              "nested": [
                {
                  "type": "property",
                  "id": "segnungen-table",
                  "display": "",
                  "properties": [
                    "segnungen"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const blessings = monster.segnungen ?? [];\nif (!Array.isArray(blessings) || blessings.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst cols = 9;\nconst renderRows = () => blessings.map(b => {\n  let rows = `<tr class=\"spell-main\"><td>${esc(b.name)}</td><td>${esc(b.probe)}</td><td>${esc(b.dauer)}</td><td>${esc(b.kap)}</td><td>${esc(b.rw)}</td><td>${esc(b.wirkungsdauer)}</td><td>${esc(b.aspekt)}</td><td>${esc(b.sf)}</td><td>${esc(b.fw ?? '0')}</td></tr>`;\n  if (b.wirkung) rows += `<tr class=\"spell-detail\"><td colspan=\"${cols}\"><strong>Wirkung:</strong> ${esc(b.wirkung)}</td></tr>`;\n  const erw = b.erweiterungen ?? [];\n  erw.forEach((e, i) => { rows += `<tr class=\"spell-detail\"><td colspan=\"${cols}\"><strong>Erweiterung ${i+1}:</strong> ${esc(e)}</td></tr>`; });\n  return rows;\n}).join('');\nreturn `<table class=\"segnungen-table\"><thead><tr><th>Segnung</th><th>Probe</th><th>Dauer</th><th>KaP-Kosten</th><th>RW</th><th>Wirkungsdauer</th><th>Aspekt</th><th>Sf.</th><th>FW</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            }
          ],
          "heading": "G√∂ttliches Wirken",
          "hasRule": false
        },
        {
          "type": "group",
          "id": "vorteile-section",
          "properties": [
            "vorteile"
          ],
          "conditioned": true,
          "nested": [
            {
              "type": "collapse",
              "id": "vorteile-collapse",
              "heading": "",
              "hasRule": false,
              "conditioned": false,
              "nested": [
                {
                  "type": "property",
                  "id": "vorteile-table",
                  "display": "",
                  "properties": [
                    "vorteile"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const items = monster.vorteile ?? [];\nif (!Array.isArray(items) || items.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst renderRows = () => items.map(v => {\n  let rows = `<tr><td><strong>${esc(v.name)}</strong></td><td>${esc(v.ap)}</td></tr>`;\n  if (v.regel) rows += `<tr class=\"detail-row\"><td colspan=\"2\" style=\"padding-left:1em;font-size:0.9em;\">${esc(v.regel)}</td></tr>`;\n  if (v.voraussetzung && v.voraussetzung !== '-') rows += `<tr class=\"detail-row\"><td colspan=\"2\" style=\"padding-left:1em;font-size:0.85em;font-style:italic;\"><strong>Voraussetzung:</strong> ${esc(v.voraussetzung)}</td></tr>`;\n  return rows;\n}).join('');\nreturn `<table class=\"vorteile-table\" style=\"width:100%;\"><thead><tr><th style=\"text-align:left;\">Vorteil</th><th style=\"width:100px;\">AP</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            }
          ],
          "heading": "Vorteile",
          "hasRule": false
        },
        {
          "type": "group",
          "id": "nachteile-section",
          "properties": [
            "nachteile"
          ],
          "conditioned": true,
          "nested": [
            {
              "type": "collapse",
              "id": "nachteile-collapse",
              "heading": "",
              "hasRule": false,
              "conditioned": false,
              "nested": [
                {
                  "type": "property",
                  "id": "nachteile-table",
                  "display": "",
                  "properties": [
                    "nachteile"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const items = monster.nachteile ?? [];\nif (!Array.isArray(items) || items.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst renderRows = () => items.map(n => {\n  let rows = `<tr><td><strong>${esc(n.name)}</strong></td><td>${esc(n.ap)}</td></tr>`;\n  if (n.regel) rows += `<tr class=\"detail-row\"><td colspan=\"2\" style=\"padding-left:1em;font-size:0.9em;\">${esc(n.regel)}</td></tr>`;\n  if (n.voraussetzung && n.voraussetzung !== '-') rows += `<tr class=\"detail-row\"><td colspan=\"2\" style=\"padding-left:1em;font-size:0.85em;font-style:italic;\"><strong>Voraussetzung:</strong> ${esc(n.voraussetzung)}</td></tr>`;\n  return rows;\n}).join('');\nreturn `<table class=\"nachteile-table\" style=\"width:100%;\"><thead><tr><th style=\"text-align:left;\">Nachteil</th><th style=\"width:100px;\">AP</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            }
          ],
          "heading": "Nachteile",
          "hasRule": false
        },
        {
          "type": "group",
          "id": "sonderfertigkeiten-section",
          "properties": [
            "sonderfertigkeiten"
          ],
          "conditioned": true,
          "nested": [
            {
              "type": "collapse",
              "id": "sonderfertigkeiten-collapse",
              "heading": "",
              "hasRule": false,
              "conditioned": false,
              "nested": [
                {
                  "type": "property",
                  "id": "sonderfertigkeiten-table",
                  "display": "",
                  "properties": [
                    "sonderfertigkeiten"
                  ],
                  "fallback": "",
                  "conditioned": true,
                  "callback": "const items = monster.sonderfertigkeiten ?? [];\nif (!Array.isArray(items) || items.length === 0) return '';\nconst esc = str => String(str ?? '-').replace(/[&<>\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',\"'\":'&#39;'}[c] || c));\nconst renderRows = () => items.map(sf => {\n  let rows = `<tr><td><strong>${esc(sf.name)}</strong></td><td>${esc(sf.kategorie ?? '-')}</td><td>${esc(sf.ap)}</td></tr>`;\n  if (sf.regel) rows += `<tr class=\"detail-row\"><td colspan=\"3\" style=\"padding-left:1em;font-size:0.9em;\">${esc(sf.regel)}</td></tr>`;\n  if (sf.voraussetzung && sf.voraussetzung !== '-') rows += `<tr class=\"detail-row\"><td colspan=\"3\" style=\"padding-left:1em;font-size:0.85em;font-style:italic;\"><strong>Voraussetzung:</strong> ${esc(sf.voraussetzung)}</td></tr>`;\n  return rows;\n}).join('');\nreturn `<table class=\"sonderfertigkeiten-table\" style=\"width:100%;\"><thead><tr><th style=\"text-align:left;\">Sonderfertigkeit</th><th>Kategorie</th><th style=\"width:100px;\">AP</th></tr></thead><tbody>${renderRows()}</tbody></table>`;"
                }
              ],
              "open": false
            }
          ],
          "heading": "Sonderfertigkeiten",
          "hasRule": false
        }
      ],
      "name": "DSA",
      "id": "d90b293b9999",
      "diceParsing": [],
      "columnWidth": 1080,
      "columns": 1,
      "cssProperties": {
        "primary-color": "#bd93f9",
        "rule-color": "#6272a4",
        "background-color": "#282a36",
        "bar-color": "#44475a",
        "bar-border-size": "1px",
        "bar-border-color": "#6272a4",
        "border-size": "1px",
        "border-color": "#44475a",
        "box-shadow-color": "rgba(0,0,0,0.3)",
        "box-shadow-x-offset": "0",
        "box-shadow-y-offset": "0",
        "box-shadow-blur": "8px",
        "font-color": "#f8f8f2",
        "font-weight": "400",
        "heading-font-color": "#ff79c6",
        "heading-font-size": "1.5em",
        "heading-font-weight": "700",
        "property-name-font-color": "#8be9fd",
        "property-name-font-weight": "bold",
        "section-heading-font-color": "#50fa7b",
        "section-heading-font-size": "1.2em",
        "section-heading-font-weight": "700",
        "section-heading-border-color": "#6272a4",
        "section-heading-border-size": "1px",
        "table-header-font-weight": "bold",
        "content-font": "inherit",
        "heading-font": "inherit",
        "image-border-size": "2px",
        "image-border-color": "#bd93f9",
        "imageWidth": "350px",
        "imageHeight": "540px"
      },
      "forceColumns": true
    }
  ],
  "default": "basic-5e-layout",
  "useDice": true,
  "renderDice": false,
  "export": true,
  "showAdvanced": true,
  "version": {
    "major": 4,
    "minor": 10,
    "patch": 2
  },
  "paths": [
    "/",
    "Statblocks"
  ],
  "autoParse": false,
  "disableSRD": false,
  "tryToRenderLinks": true,
  "debug": false,
  "notifiedOfFantasy": false,
  "hideConditionHelp": false,
  "alwaysImport": false,
  "defaultLayoutsIntegrated": true,
  "atomicWrite": false
}